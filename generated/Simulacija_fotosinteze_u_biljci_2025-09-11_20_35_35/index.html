<!DOCTYPE html>
<html lang="sr">
<head>
<meta charset="utf-8" />
<title>Simulacija fotosinteze u biljci</title>
<style>
  :root{
    --bg:#f3fff7;
    --panel:#ffffffcc;
    --accent:#2f8f2f;
  }
  html,body{
    height:100%;
    margin:0;
    font-family: "Segoe UI", Roboto, Arial, sans-serif;
    background: linear-gradient(180deg,#e8fbf0 0%, var(--bg) 100%);
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }
  .container{
    width:100%;
    max-width:1000px;
    margin:24px auto;
    padding:18px;
    box-sizing:border-box;
  }
  header{
    text-align:left;
    margin-bottom:10px;
  }
  h1{
    margin:0 0 6px 0;
    color:#0b5a2e;
    font-size:28px;
    letter-spacing:0.2px;
  }
  p.description{
    margin:0 0 12px 0;
    color:#064d2a;
    background:var(--panel);
    padding:12px;
    border-radius:8px;
    box-shadow:0 2px 6px rgba(0,0,0,0.06);
  }
  .canvas-wrap{
    position:relative;
    background:linear-gradient(180deg, rgba(255,255,255,0.6), rgba(245,255,240,0.9));
    border-radius:12px;
    padding:12px;
    box-shadow:0 4px 18px rgba(20,60,30,0.08);
  }
  canvas{
    display:block;
    width:100%;
    height:auto;
    border-radius:8px;
    background:transparent;
    cursor:pointer;
  }
  .legend{
    margin-top:10px;
    color:#07522a;
    font-size:14px;
    display:flex;
    gap:14px;
    flex-wrap:wrap;
  }
  .hint{
    font-size:13px;
    color:#07401f;
    opacity:0.9;
  }
  .toast{
    position:absolute;
    left:50%;
    transform:translateX(-50%);
    top:12px;
    background:rgba(0,0,0,0.7);
    color:white;
    padding:8px 12px;
    border-radius:10px;
    font-size:14px;
    pointer-events:none;
    opacity:0;
    transition:opacity .25s ease, transform .25s ease;
  }
  .toast.show{
    opacity:1;
    transform:translateX(-50%) translateY(0);
  }
  /* audience metadata in comment for developers */
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>Simulacija fotosinteze u biljci</h1>
    <p class="description">Ovaj interaktivni alat omogućava učenicima da vizuelno i kroz interakciju istraže proces fotosinteze. Alat prikazuje biljku, sunce i listove, a korisnik može klikom na sunce ili listove menjati intenzitet svetlosti i prisustvo vode. Promene se odmah reflektuju kroz boje listova, nastanak kiseonika i rast biljke, što pomaže učenicima da shvate kako svetlost i voda utiču na fotosintezu.</p>
  </header>

  <div class="canvas-wrap" id="wrap" style="min-height:560px;">
    <div class="toast" id="toast"></div>
    <canvas id="scene" width="960" height="560" title="Klikni na sunce, kap vode ili listove"></canvas>
    <div class="legend">
      <div class="hint">Klikni na sunce (gornji levi ugao) da povećaš svetlost</div>
      <div class="hint">Klikni na kap vode (pored biljke) da navlažiš biljku</div>
      <div class="hint">Klikni na list da vidiš oslobađanje kiseonika</div>
    </div>
  </div>
</div>

<!-- audience: osnovnoškolci i srednjoškolci -->
<script>
/*
  Interaktivni alat:
  - Implementira ponašanje opisano u JSON ulazu.
  - Objekti: sunce, kap vode, listovi (skup listova).
  - Prati broj klikova po objektu i izvršava then_first na prvom kliku, pa redom then_next.
  - Extras: animacije zraka sunca, kapanje vode, mehurići kiseonika, rast biljke.
*/

(function(){
  const canvas = document.getElementById('scene');
  const ctx = canvas.getContext('2d');
  const toastEl = document.getElementById('toast');
  let W = canvas.width, H = canvas.height;

  function resizeCanvas(){
    // Keep canvas size fixed in pixels but ensure CSS scales nicely already set.
    W = canvas.width = 960;
    H = canvas.height = 560;
  }
  resizeCanvas();

  // Scene state
  const state = {
    // Sun
    sun: { x:80, y:80, r:48, color:'#ffd54a', clicks:0, rays:false, lightIntensity:0 }, // lightIntensity 0 or 1
    // Water drop
    water: { x:600+40, y:H-180, r:22, color:'#4fc3f7', clicks:0, dripping:false, droplets:[] , hydrated:false},
    // Plant
    plant: {
      x: W/2 - 60, // base x
      y: H - 140,  // base y for pot top
      scale: 1.0,
      targetScale: 1.0,
      leavesColor:'#9be29b', // initial light green
      clicksOnLeaves:0,
      bubbles: []
    },
    // visual flags
    messages: [], // {text, ttl, alpha, x,y}
    time:0
  };

  // Pre-calc leaf positions relative to plant center
  const leafTemplates = [
    {dx: -20, dy:-30, rot:-25, w:60, h:32},
    {dx: 20, dy:-30, rot:25, w:60, h:32},
    {dx: -36, dy:-6, rot:-50, w:54, h:28},
    {dx: 36, dy:-6, rot:50, w:54, h:28},
    {dx: 0, dy:-54, rot:0, w:48, h:26}
  ];

  // Utility: show short toast
  function showToast(text,duration=2200){
    toastEl.textContent = text;
    toastEl.classList.add('show');
    clearTimeout(toastEl._hideTimer);
    toastEl._hideTimer = setTimeout(()=>{ toastEl.classList.remove('show'); }, duration);
  }

  // Click handling
  canvas.addEventListener('click', function(ev){
    const rect = canvas.getBoundingClientRect();
    const cx = (ev.clientX - rect.left) * (canvas.width / rect.width);
    const cy = (ev.clientY - rect.top) * (canvas.height / rect.height);

    // Check sun hit
    const s = state.sun;
    if (pointInCircle(cx,cy,s.x,s.y,s.r)){
      handleSunClick();
      return;
    }
    // Check water hit
    const w = state.water;
    if (pointInDrop(cx,cy,w.x,w.y,w.r)){
      handleWaterClick();
      return;
    }
    // Check leaves hit area (approx around plant center)
    const plantCenter = {x: state.plant.x+70, y: state.plant.y - 40};
    if (pointInRect(cx,cy, plantCenter.x - 85, plantCenter.y - 80, 170, 140)){
      handleLeavesClick();
      return;
    }
  });

  function pointInCircle(px,py,cx,cy,r){
    const dx=px-cx, dy=py-cy;
    return dx*dx+dy*dy <= r*r;
  }
  function pointInRect(px,py,x,y,w,h){
    return px>=x && px<=x+w && py>=y && py<=y+h;
  }
  // Simple hit for drop shape (teardrop), check circle + triangle-ish top region
  function pointInDrop(px,py,cx,cy,r){
    // circle base
    if (pointInCircle(px,py,cx,cy,r)) return true;
    // top triangle
    const top = {x:cx, y:cy - r - 10};
    // check bounding box
    const minX = Math.min(cx,r, top.x - r);
    const maxX = Math.max(cx + r, top.x + r);
    if (px < minX || px > maxX || py < top.y || py > cy) return false;
    // rough distance to top
    const dx = Math.abs(px - cx);
    const dy = py - top.y;
    return dy >= 0 && dx <= (r * (1 - dy/(r*2)));
  }

  // Handlers implementing then_first and then_next sequences
  function handleSunClick(){
    const s = state.sun;
    s.clicks++;
    if (s.clicks === 1){
      // then_first: pojačaj svetlost i učini listove tamnozelenim
      s.lightIntensity = 1;
      state.plant.leavesColor = '#2f8f2f'; // dark green
      showToast('Svetlost pojačana — listovi tamnozeleni');
      // check combined growth
      checkGrowthCondition();
    } else {
      // then_next sequence:
      const actions = [
        'dodaj zračenje koje animira kretanje svetlosnih zraka',
        "prikazi mali tekst 'Fotosinteza pojačana!'"
      ];
      const idx = (s.clicks - 2) % actions.length;
      const action = actions[idx];
      if (action.includes('zračenje')) {
        s.rays = true;
        showToast('Sunčevi zraci animirani');
      } else if (action.includes('Fotosinteza')) {
        flashMessage("Fotosinteza pojačana!", 2200);
      }
      // clicking sun also increments overall lightIntensity effect (small boost)
      s.lightIntensity = Math.min(2, s.lightIntensity + 0.25);
      checkGrowthCondition();
    }
  }

  function handleWaterClick(){
    const w = state.water;
    w.clicks++;
    if (w.clicks === 1){
      // then_first: listovi postaju živopisno zeleni, biljka raste za malu visinu
      state.plant.leavesColor = '#2ecc40'; // vivid green
      state.plant.targetScale = Math.min(1.15, state.plant.targetScale + 0.12);
      w.hydrated = true;
      showToast('Biljka upila vodu — lišće živopisno zeleno');
      checkGrowthCondition();
    } else {
      // then_next sequence
      const actions = [
        'dodaj animaciju kapanja vode ka listovima',
        "prikazi tekst 'Biljka hidrira!'"
      ];
      const idx = (w.clicks - 2) % actions.length;
      const action = actions[idx];
      if (action.includes('kapanja')){
        startDroplets();
        showToast('Kapanje vode ka listovima');
      } else if (action.includes('Biljka hidrira')){
        flashMessage("Biljka hidrira!", 2000);
      }
      // repeated water clicks can increase hydration
      if (w.hydrated) {
        state.plant.targetScale = Math.min(1.4, state.plant.targetScale + 0.06);
      }
      checkGrowthCondition();
    }
  }

  function handleLeavesClick(){
    const p = state.plant;
    p.clicksOnLeaves = (p.clicksOnLeaves || 0) + 1;
    if (p.clicksOnLeaves === 1){
      // then_first: prikaži mehuriće kiseonika kako izlaze iz lista
      spawnBubbles(10);
      showToast('Kiseonik se oslobađa (mehurići)');
    } else {
      const actions = [
        "prikazi tekst 'Kiseonik se oslobađа'",
        "mehurići se podižu i nestaju"
      ];
      const idx = (p.clicksOnLeaves - 2) % actions.length;
      const action = actions[idx];
      if (action.includes('prikazi tekst')) {
        flashMessage("Kiseonik se oslobađa", 2000);
      } else if (action.includes('mehurići')) {
        spawnBubbles(18, true);
      }
    }
  }

  function startDroplets(){
    const w = state.water;
    w.dripping = true;
    // spawn multiple droplets traveling toward leaves
    for (let i=0;i<6;i++){
      setTimeout(()=> spawnDroplet(), i*220);
    }
    // keep dripping for a short while
    clearTimeout(w._stopDropping);
    w._stopDropping = setTimeout(()=> { w.dripping = false; }, 2500);
  }
  function spawnDroplet(){
    const w = state.water;
    const p = state.plant;
    const start = {x:w.x + (Math.random()*12-6), y:w.y - w.r + 4};
    const end = {x: p.x+70 + (Math.random()*40-20), y: p.y - 40 + (Math.random()*12-6)};
    const droplet = {
      x: start.x, y: start.y, r:6, alpha:1,
      vx: (end.x - start.x)/30 + (Math.random()-0.5),
      vy: (end.y - start.y)/30 + (Math.random()*0.6),
      life:30
    };
    state.water.droplets.push(droplet);
  }

  function spawnBubbles(count=8, strong=false){
    const p = state.plant;
    for (let i=0;i<count;i++){
      const baseX = p.x+70 + (Math.random()*80-40);
      const baseY = p.y - 50 + (Math.random()*20-10);
      const b = {
        x: baseX,
        y: baseY,
        r: Math.random()*6 + (strong?4:2),
        vy: -(0.6 + Math.random()*1.4 + (strong?0.8:0)),
        vx: Math.random()*0.8-0.4,
        alpha:1,
        life: 60 + Math.floor(Math.random()*40)
      };
      p.bubbles.push(b);
    }
  }

  function flashMessage(text, ttl=1800){
    state.messages.push({text, ttl, alpha:1, x: W/2, y: 60});
  }

  // Growth condition: if sun.lightIntensity high enough AND water hydrated then grow more
  function checkGrowthCondition(){
    if (state.sun.lightIntensity >= 0.9 && state.water.hydrated){
      // start growth animation to larger size
      state.plant.targetScale = Math.min(1.6, state.plant.targetScale + 0.25);
      flashMessage('Dovoljno svetla i vode — biljka raste!', 2200);
    }
  }

  // Main render loop
  function update(dt){
    state.time += dt;
    // Smooth scale interpolation
    const p = state.plant;
    p.scale += (p.targetScale - p.scale) * 0.06;

    // Update droplets
    const droplets = state.water.droplets;
    for (let i=droplets.length-1;i>=0;i--){
      const d = droplets[i];
      d.x += d.vx; d.y += d.vy;
      d.life--;
      d.alpha = d.life/40;
      if (d.life <=0) droplets.splice(i,1);
      // when reach near leaves, spawn tiny splash bubble and slightly increase hydration/growth
      if (d.life>0 && d.y < p.y - 40 && Math.abs(d.x - (p.x+70))<40){
        if (!d._splash){
          d._splash = true;
          spawnBubbles(4);
          state.plant.targetScale = Math.min(1.6, state.plant.targetScale + 0.02);
        }
      }
    }

    // Update bubbles
    for (let i=p.bubbles.length-1;i>=0;i--){
      const b = p.bubbles[i];
      b.x += b.vx;
      b.y += b.vy;
      b.life--;
      b.alpha = Math.max(0, b.life/100);
      if (b.life<=0) p.bubbles.splice(i,1);
    }

    // Messages ttl
    for (let i=state.messages.length-1;i>=0;i--){
      const m = state.messages[i];
      m.ttl -= dt;
      if (m.ttl <= 0) state.messages.splice(i,1);
    }

    // Slight ambient pulsing when strong light
    if (state.sun.lightIntensity >= 1.5){
      // subtle additional growth nudges
      p.targetScale = Math.min(1.8, p.targetScale + 0.0008 * dt);
    }
  }

  function draw(){
    // Clear
    ctx.clearRect(0,0,W,H);

    // Background sky/ground
    drawBackground();

    // Sun
    drawSun();

    // Light rays if any
    if (state.sun.rays) drawSunRays();

    // Plant: pot, stem, leaves
    drawPlant();

    // Water drop
    drawWaterDrop();

    // Droplets
    drawDroplets();

    // Bubbles
    drawBubbles();

    // HUD messages
    drawMessages();

    // Optional small labels for initial hints (static)
    drawLegendIcons();
  }

  function drawBackground(){
    // soft ground
    const g = ctx.createLinearGradient(0, H*0.6, 0, H);
    g.addColorStop(0, 'rgba(220,255,220,0.7)');
    g.addColorStop(1, 'rgba(200,245,200,1)');
    ctx.fillStyle = g;
    ctx.fillRect(0, H*0.6, W, H*0.4);
    // slight gradient top
    const sky = ctx.createLinearGradient(0,0,0,H*0.6);
    sky.addColorStop(0,'#fffefc');
    sky.addColorStop(1,'#e8fbf0');
    ctx.fillStyle = sky;
    ctx.fillRect(0,0,W,H*0.6);
  }

  function drawSun(){
    const s = state.sun;
    // glow
    const glow = ctx.createRadialGradient(s.x, s.y, s.r*0.2, s.x, s.y, s.r*2.2);
    glow.addColorStop(0, 'rgba(255,230,120,0.95)');
    glow.addColorStop(0.5, 'rgba(255,215,80,0.55)');
    glow.addColorStop(1, 'rgba(255,215,60,0.08)');
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r*2.2, 0, Math.PI*2);
    ctx.fill();

    // sun body
    ctx.beginPath();
    const sunColor = s.color;
    ctx.fillStyle = sunColor;
    ctx.strokeStyle = '#e6b800';
    ctx.lineWidth = 2;
    ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();

    // small rays when high intensity
    if (s.lightIntensity > 0.6) {
      const num = 10;
      for (let i=0;i<num;i++){
        const a = (i/num)*Math.PI*2 + (state.time*0.002*(1+i%3));
        const len = s.r + 18 + Math.sin(state.time*0.01 + i)*6 * s.lightIntensity;
        const x1 = s.x + Math.cos(a)*(s.r+4);
        const y1 = s.y + Math.sin(a)*(s.r+4);
        const x2 = s.x + Math.cos(a)*len;
        const y2 = s.y + Math.sin(a)*len;
        ctx.beginPath();
        ctx.moveTo(x1,y1);
        ctx.lineTo(x2,y2);
        ctx.strokeStyle = 'rgba(255,235,120,' + (0.12 + 0.06*i/num*s.lightIntensity) + ')';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }
  }

  function drawSunRays(){
    const s = state.sun;
    // animated soft rays from sun to plant area
    const center = {x: s.x, y: s.y};
    const pCenter = {x: state.plant.x+70, y: state.plant.y - 40};
    const dx = pCenter.x - center.x, dy = pCenter.y - center.y;
    const angle = Math.atan2(dy,dx);
    const lenBase = Math.hypot(dx,dy);
    // draw multiple rays with slight wobble
    for (let i=0;i<6;i++){
      const t = state.time*0.006 + i;
      const wob = Math.sin(t)*6;
      const startX = center.x + Math.cos(angle + wob*0.01)*(state.sun.r - 6);
      const startY = center.y + Math.sin(angle + wob*0.01)*(state.sun.r - 6);
      const endX = center.x + Math.cos(angle + wob*0.02) * (lenBase - 30 + Math.sin(t*0.7)*20);
      const endY = center.y + Math.sin(angle + wob*0.02) * (lenBase - 30 + Math.cos(t*0.7)*20);
      ctx.beginPath();
      ctx.moveTo(startX,startY);
      ctx.lineTo(endX,endY);
      ctx.strokeStyle = 'rgba(255,240,160,' + (0.08 + 0.06*i/6) + ')';
      ctx.lineWidth = 8 - i;
      ctx.stroke();
    }
  }

  function drawPlant(){
    const p = state.plant;
    const baseX = p.x;
    const baseY = p.y;
    const scale = p.scale;
    ctx.save();
    ctx.translate(baseX + 70, baseY); // plant center reference
    ctx.scale(scale, scale);

    // Pot
    ctx.save();
    ctx.translate(-70, 60);
    drawPot();
    ctx.restore();

    // Stem
    ctx.beginPath();
    ctx.fillStyle = '#6b8b46';
    ctx.roundRect(-10, -20, 20, 100, 8);
    ctx.fill();

    // Leaves (templates around center)
    for (let i=0;i<leafTemplates.length;i++){
      const lt = leafTemplates[i];
      ctx.save();
      ctx.translate(lt.dx, lt.dy - 20);
      ctx.rotate(lt.rot * Math.PI/180);
      drawLeaf(0,0, lt.w, lt.h, p.leavesColor);
      ctx.restore();
    }

    ctx.restore();
  }

  function drawLeaf(x,y,w,h,color){
    // leaf body with gradient
    const g = ctx.createLinearGradient(x-w/2,y-h/2,x+w/2,y+h/2);
    g.addColorStop(0, shadeColor(color, -8));
    g.addColorStop(0.5, color);
    g.addColorStop(1, shadeColor(color, 10));
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.ellipse(x,y,w/2,h/2,0,0,Math.PI*2);
    ctx.fill();

    // central vein
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 2;
    ctx.moveTo(x - w*0.15, y);
    ctx.quadraticCurveTo(x, y, x + w*0.15, y);
    ctx.stroke();
  }

  function drawPot(){
    // simple pot under plant
    ctx.beginPath();
    ctx.fillStyle = '#b36b3c';
    ctx.strokeStyle = '#9a5130';
    ctx.lineWidth = 2;
    ctx.ellipse(0, 20, 70, 22, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();

    ctx.beginPath();
    ctx.rect(-60, -6, 120, 30);
    ctx.fillStyle = '#c97b50';
    ctx.fill();
    ctx.stroke();
  }

  function drawWaterDrop(){
    const w = state.water;
    // teardrop shape
    ctx.save();
    ctx.translate(w.x, w.y);
    // glow
    ctx.beginPath();
    const grad = ctx.createRadialGradient(0, -4, 4, 0, 6, 36);
    grad.addColorStop(0, 'rgba(115,205,255,0.9)');
    grad.addColorStop(1, 'rgba(115,205,255,0.06)');
    ctx.fillStyle = grad;
    ctx.arc(0,0,w.r*2.2,0,Math.PI*2);
    ctx.fill();

    // body
    ctx.beginPath();
    ctx.moveTo(0, -w.r-8);
    ctx.quadraticCurveTo(w.r+6, 0, 0, w.r+6);
    ctx.quadraticCurveTo(-w.r-6, 0, 0, -w.r-8);
    ctx.fillStyle = w.color;
    ctx.fill();
    ctx.strokeStyle = 'rgba(20,110,170,0.6)';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.restore();
  }

  function drawDroplets(){
    const droplets = state.water.droplets;
    for (let i=0;i<droplets.length;i++){
      const d = droplets[i];
      ctx.beginPath();
      ctx.fillStyle = 'rgba(90,190,240,' + Math.max(0.12,d.alpha) + ')';
      ctx.ellipse(d.x, d.y, d.r, d.r*1.2, 0, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function drawBubbles(){
    const bubs = state.plant.bubbles;
    for (let i=0;i<bubs.length;i++){
      const b = bubs[i];
      ctx.beginPath();
      ctx.fillStyle = 'rgba(255,255,255,' + (0.6*b.alpha) + ')';
      ctx.strokeStyle = 'rgba(160,220,255,' + (0.8*b.alpha) + ')';
      ctx.lineWidth = 1;
      ctx.ellipse(b.x, b.y, b.r, b.r, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
    }
  }

  function drawMessages(){
    // center messages
    for (let i=0;i<state.messages.length;i++){
      const m = state.messages[i];
      const alpha = Math.max(0, Math.min(1, m.ttl/2000));
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = 'rgba(8,48,20,0.98)';
      ctx.font = 'bold 18px system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(m.text, m.x, m.y);
      ctx.restore();
    }
    // optionally small static label near sun/water
    ctx.save();
    ctx.font = '12px system-ui, sans-serif';
    ctx.fillStyle = '#2d6b2f';
    ctx.fillText('Sunce — klikni', state.sun.x, state.sun.y + 72);
    ctx.fillText('Kap vode — klikni', state.water.x, state.water.y + 42);
    ctx.restore();
  }

  function drawLegendIcons(){
    // draw a small caption for leaves area
    ctx.save();
    ctx.fillStyle = '#0b4b24';
    ctx.font = '12px system-ui, sans-serif';
    ctx.fillText('Listovi — klikni za oslobađanje kiseonika', state.plant.x + 30, state.plant.y - 80);
    ctx.restore();
  }

  // Animation loop
  let last = performance.now();
  function tick(now){
    const dt = Math.min(40, now - last);
    last = now;
    update(dt);
    draw();
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // Utilities
  function shadeColor(color, percent) {
    // color in hex (#rrggbb)
    const num = parseInt(color.replace('#',''),16);
    let r = (num>>16) + percent;
    let g = ((num>>8)&0x00FF) + percent;
    let b = (num & 0x0000FF) + percent;
    r = Math.max(0,Math.min(255,r));
    g = Math.max(0,Math.min(255,g));
    b = Math.max(0,Math.min(255,b));
    return '#' + (r.toString(16).padStart(2,'0')) + (g.toString(16).padStart(2,'0')) + (b.toString(16).padStart(2,'0'));
  }

  // add roundRect to CanvasRenderingContext2D if not exists
  if (!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
      if (typeof r === 'undefined') r = 5;
      if (typeof r === 'number') r = {tl: r, tr: r, br: r, bl: r};
      this.beginPath();
      this.moveTo(x + r.tl, y);
      this.lineTo(x + w - r.tr, y);
      this.quadraticCurveTo(x + w, y, x + w, y + r.tr);
      this.lineTo(x + w, y + h - r.br);
      this.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
      this.lineTo(x + r.bl, y + h);
      this.quadraticCurveTo(x, y + h, x, y + h - r.bl);
      this.lineTo(x, y + r.tl);
      this.quadraticCurveTo(x, y, x + r.tl, y);
      this.closePath();
    };
  }

  // Responsive: adapt canvas display size while keeping internal resolution
  window.addEventListener('resize', function(){
    // no dynamic changes necessary because canvas dimensions fixed; CSS scales
  });

  // Simple exposure for debugging in console (not required)
  window._fotosintezaState = state;

})();
</script>
</body>
</html>