<!DOCTYPE html>
<html lang="sr">
<head>
<meta charset="utf-8" />
<title>Tretman vode</title>
<style>
  /* Audience (meta): Studenti trece godine */
  /* Osnovni raspored */
  body {
    font-family: Arial, Helvetica, sans-serif;
    margin: 0;
    background: #f3f6fb;
    color: #123;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  header {
    width: 100%;
    background: linear-gradient(90deg,#0d47a1,#1976d2);
    color: white;
    padding: 18px 24px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  }
  h1 { margin: 0; font-size: 28px; }
  main { max-width: 1100px; width: 100%; padding: 18px; }

  p.description {
    background: white;
    padding: 14px;
    border-radius: 8px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.06);
    margin: 12px 0 18px 0;
    line-height: 1.45;
  }

  /* SVG container style */
  .viz {
    background: linear-gradient(#eaf4ff, #dff0ff);
    border-radius: 10px;
    padding: 12px;
    box-shadow: 0 6px 20px rgba(16,40,80,0.08);
  }

  .controls {
    margin-top: 12px;
    display:flex;
    gap:10px;
    align-items:center;
  }

  button.control {
    padding:8px 12px;
    border-radius:6px;
    border: 1px solid rgba(0,0,0,0.08);
    background: linear-gradient(#fff,#f6f9ff);
    cursor: pointer;
    box-shadow: 0 1px 3px rgba(0,0,0,0.06);
  }
  button.control:active { transform: translateY(1px); }

  .legend {
    margin-left: auto;
    font-size: 13px;
    color:#264;
    display:flex;
    gap:10px;
    align-items:center;
  }
  .badge {
    display:inline-flex;
    align-items:center;
    gap:6px;
    padding:6px 8px;
    background:rgba(255,255,255,0.8);
    border-radius:6px;
    border:1px solid rgba(0,0,0,0.04);
  }
  .dot { width:12px;height:12px;border-radius:50%; }

  /* tooltip */
  .tooltip {
    position: absolute;
    pointer-events: none;
    background: rgba(0,0,0,0.8);
    color: white;
    padding:6px 8px;
    border-radius:6px;
    font-size: 13px;
    display:none;
    z-index: 20;
  }

  footer.note {
    margin-top: 12px;
    font-size: 13px;
    color: #456;
  }

  /* small responsive */
  @media (max-width: 900px) {
    main { padding: 10px; }
    svg { width: 100%; height: auto; }
  }
</style>
</head>
<body>
  <header>
    <h1>Tretman vode</h1>
  </header>

  <main>
    <p class="description">
      Na slici je prikazan rezervoar s vodom i nagnutom metalnom rešetkom koja odvaja krupnije čestice iz protoka vode. Voda prolazi kroz uske proreze rešetke, dok se čvrsti otpad zadržava na lamelama. Iznad rešetke se vidi kućica s mehanizmom koji podiže i skida uhvaćeni otpad. U uvećanom krugu jasno su prikazane uhvaćene čestice i način kako se zaustavljaju na rešetki.
    </p>

    <div class="viz" id="vizWrap">
      <!-- SVG scena -->
      <svg id="scene" width="1000" height="520" viewBox="0 0 1000 520" style="display:block; border-radius:8px;">
        <defs>
          <linearGradient id="waterGrad" x1="0" x2="0" y1="0" y2="1">
            <stop offset="0%" stop-color="#5fc6ff"/>
            <stop offset="100%" stop-color="#2b9cff"/>
          </linearGradient>

          <linearGradient id="metal" x1="0" x2="1">
            <stop offset="0%" stop-color="#d6d6d6"/>
            <stop offset="100%" stop-color="#9aa0a6"/>
          </linearGradient>

          <pattern id="wavePattern" patternUnits="userSpaceOnUse" width="60" height="20">
            <path d="M0 12 q15 -12 30 0 t30 0" stroke="#bfe8ff" stroke-width="4" fill="none" stroke-linecap="round"></path>
          </pattern>

          <filter id="softShadow" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="0" dy="4" stdDeviation="6" flood-color="#000" flood-opacity="0.15"/>
          </filter>
        </defs>

        <!-- kanal i okolni elementi -->
        <rect x="40" y="140" width="920" height="220" rx="10" fill="#e6eefb" stroke="#c7defa" stroke-width="2"></rect>

        <!-- voda (animated via JS by moving group) -->
        <g id="waterGroup" clip-path="url(#waterClip)">
          <rect id="waterRect" x="40" y="160" width="920" height="180" fill="url(#waterGrad)"></rect>
          <rect x="40" y="160" width="920" height="180" fill="url(#wavePattern)" opacity="0.55"></rect>
        </g>

        <clipPath id="waterClip">
          <rect x="40" y="160" width="920" height="180"></rect>
        </clipPath>

        <!-- Bubanj-sito (rotirajući bubanj) -->
        <!-- Place rotated cylinder approximated by an ellipse and grid slits -->
        <g id="drumGroup" transform="translate(480,250) rotate(-18)">
          <g id="drum" cursor="pointer">
            <ellipse cx="0" cy="0" rx="200" ry="70" fill="url(#metal)" stroke="#7e848a" stroke-width="2" filter="url(#softShadow)"></ellipse>

            <!-- slits: multiple rectangles clipped along ellipse band -->
            <g id="slits" fill="#f2f5f7" opacity="0.75"></g>

            <!-- mark center for debugging
            <circle cx="0" cy="0" r="3" fill="red"></circle>
            -->
          </g>

          <!-- axle/shaft -->
          <rect x="-210" y="-8" width="420" height="16" rx="8" fill="#666" opacity="0.9"></rect>
        </g>

        <!-- Collector under drum -->
        <g id="collector" transform="translate(480,330)">
          <rect x="-220" y="0" width="440" height="60" rx="6" fill="#e9e7e6" stroke="#bdb9b7" stroke-width="1.5"></rect>
          <text x="0" y="38" font-size="12" text-anchor="middle" fill="#4b4b4b">Kolektor sakupljenog otpada</text>
        </g>

        <!-- Machine housing and control box -->
        <g id="machine" transform="translate(720,70)">
          <rect x="-40" y="-10" width="120" height="90" rx="8" fill="#fff" stroke="#c7d0db"></rect>
          <rect x="10" y="18" width="36" height="36" rx="6" id="controlBox" class="clickable" fill="#fffbeb" stroke="#e8d08f" cursor="pointer"></rect>
          <text x="50" y="40" font-size="11" fill="#3a3a3a">Upravljač</text>
          <rect x="5" y="-6" width="36" height="12" rx="3" fill="#d7e3ff" stroke="#a8c0ff"></rect>
        </g>

        <!-- Person monitoring -->
        <g id="person" transform="translate(820,230)" cursor="pointer" class="clickable">
          <circle cx="0" cy="-10" r="14" fill="#ffd5b8" stroke="#e6bca0"></circle>
          <rect x="-10" y="4" width="20" height="28" rx="4" fill="#4aa3ff"></rect>
        </g>

        <!-- Magnifier/zoom circle showing captured detail -->
        <g id="zoom" transform="translate(880,80)" cursor="pointer" class="clickable">
          <circle cx="0" cy="0" r="60" fill="#fff" stroke="#b6d5ff" stroke-width="3"></circle>
          <text x="0" y="-28" text-anchor="middle" font-size="12" fill="#2b5f8b">Uvećanje</text>
          <text x="0" y="0" text-anchor="middle" font-size="11" fill="#2b5f8b">Klik za detalj</text>
        </g>

        <!-- Zoom detail group (hidden initially) -->
        <g id="zoomDetail" transform="translate(880,80)" opacity="0">
          <rect x="-110" y="-110" width="220" height="220" rx="8" fill="#fff" stroke="#b6d5ff"></rect>
          <g transform="translate(-35,-20) scale(0.9)" id="zoomContent"></g>
          <text x="0" y="100" text-anchor="middle" font-size="12" fill="#264">Uhvaćene čestice na lamelama</text>
        </g>

        <!-- dynamic debris group -->
        <g id="debrisLayer"></g>

        <!-- labels -->
        <text x="70" y="150" font-size="13" fill="#16324a">Tok vode</text>

      </svg>

      <div class="controls" style="position:relative; margin-top:10px;">
        <button id="btnToggleDrum" class="control">Pokreni bubanj</button>
        <button id="btnLift" class="control">Podigni otpad</button>
        <div class="legend">
          <div class="badge"><div class="dot" style="background:#8f6b4a"></div> Otpad</div>
          <div class="badge"><div class="dot" style="background:#3aa0ff"></div> Voda</div>
        </div>
      </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <footer class="note">
      Interakcija: Kliknite na bubanj da startujete / menjate brzinu rotacije. Kliknite na upravljač da podignete i ispraznite kolektor. Kliknite na uvećanje da vidite detalj kako čestice stoje na lamelama.
    </footer>
  </main>

<script>
/*
  JSON parsed mapping (for reference inside script):
  title: "Tretman vode"
  audience: "Studenti trece godine"  (meta - included as comment above)
  description: ... (displayed)
  initial: ... (scene created below)
  interactions: []  -> no explicit if-then rules provided, so internal interactive rules are implemented.
  extras: "" (none)
*/

/* Scene parameters */
const svg = document.getElementById('scene');
const debrisLayer = document.getElementById('debrisLayer');
const slitsGroup = document.getElementById('slits');
const drumGroup = document.getElementById('drumGroup');
const drum = document.getElementById('drum');
const collector = document.getElementById('collector');
const controlBox = document.getElementById('controlBox');
const zoom = document.getElementById('zoom');
const zoomDetail = document.getElementById('zoomDetail');
const zoomContent = document.getElementById('zoomContent');
const tooltip = document.getElementById('tooltip');

/* Interaction state tracking for IF-THEN sequences */
const clickCounts = {
  drum: 0,
  control: 0,
  person: 0,
  zoom: 0
};
/* Drum state */
let drumRotation = 0; // degrees
let drumSpeed = 0; // degrees per second
let drumState = 'stopped'; // 'stopped', 'slow', 'fast'

/* debris management */
let debrisIdCounter = 0;
let debrisObjects = []; // {id, cx, cy, vx, vy, attached:false, attachedAngle:..., el}
let attachedDebris = []; // debris attached to drum (indices)
let collectorCount = 0;

/* animation loop */
let lastTime = null;

/* Create slits on drum surface (represent lamella/mesh) */
function createSlits() {
  // We'll create parallel slots across drum band
  slitsGroup.innerHTML = '';
  const slotCount = 16;
  const bandHeight = 36;
  for (let i=0;i<slotCount;i++) {
    const x = -170 + (i * (340 / (slotCount-1)));
    const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
    rect.setAttribute('x', x);
    rect.setAttribute('y', -bandHeight/2);
    rect.setAttribute('width', 12);
    rect.setAttribute('height', bandHeight);
    rect.setAttribute('rx',2);
    rect.setAttribute('fill','#cfd6db');
    rect.setAttribute('opacity',0.85);
    rect.setAttribute('transform','rotate(0 '+x+' 0)');
    slitsGroup.appendChild(rect);
  }
}
createSlits();

/* Utility create debris */
function spawnDebris() {
  const id = ++debrisIdCounter;
  // spawn inside water left side
  const x = 80 + Math.random() * 120;
  const y = 220 + Math.random() * 100;
  const size = 8 + Math.random()*10;
  const colorSet = ['#8f6b4a','#7d5a3f','#6f5236','#5e4630'];
  const color = colorSet[Math.floor(Math.random()*colorSet.length)];
  const el = document.createElementNS('http://www.w3.org/2000/svg','g');
  el.setAttribute('id','debris'+id);
  const shape = document.createElementNS('http://www.w3.org/2000/svg','path');
  // irregular shape path
  const p = makeLeafPath(size);
  shape.setAttribute('d', p);
  shape.setAttribute('fill', color);
  shape.setAttribute('stroke','#3b2a21');
  shape.setAttribute('stroke-width',0.6);
  shape.setAttribute('opacity', 0.95);
  el.appendChild(shape);
  debrisLayer.appendChild(el);

  const vx = 30 + Math.random()*45; // px / second to right
  const obj = {id, cx:x, cy:y, vx, vy:0, attached:false, attachedAngle:0, size, color, el};
  updateDebrisElement(obj);
  debrisObjects.push(obj);
}

/* leaf-like path generator */
function makeLeafPath(r) {
  // simple blob path
  return `M ${-r*0.6} 0 q ${r*0.2} ${-r*0.9} ${r*0.9} ${-r*0.2} q ${r*0.4} ${r*0.6} ${-r*0.4} ${r*0.95} q ${-r*1.0} ${r*0.25} ${-r*1.4} ${-r*0.7} z`;
}

/* Update debris DOM transform */
function updateDebrisElement(obj) {
  obj.el.setAttribute('transform', `translate(${obj.cx},${obj.cy}) rotate(${obj.attached? obj.attachedAngle : 0}) scale(${1})`);
}

/* Collision detection between debris and drum band.
   DrumGroup is at translate(480,250) rotate(-18)
   We'll compute debris position in drumGroup local coordinates and test distance to ellipse boundary */
function checkDebrisCollision(obj) {
  // transform debris point into drumGroup local coords
  const t = {x: obj.cx, y: obj.cy};
  // drumGroup transform: translate(480,250) rotate(-18)
  const tx = t.x - 480;
  const ty = t.y - 250;
  const angle = -18 * Math.PI/180;
  // rotate by -angle (because group rotated -18, to get local rotate back by +18)
  const cosA = Math.cos(-angle);
  const sinA = Math.sin(-angle);
  const lx = cosA * tx - sinA * ty;
  const ly = sinA * tx + cosA * ty;
  // ellipse parameters rx=200, ry=70
  const rx = 200, ry = 70;
  const value = (lx*lx)/(rx*rx) + (ly*ly)/(ry*ry);
  // Consider band area (near top surface): we want debris that reach outer rim (value <=1.05 but y small)
  // Also ensure debris are coming from left and near upper half surface
  if (value <= 1.05 && ly < 10 && lx > -60 && lx < 60) {
    return {hit: true, lx, ly};
  }
  return {hit:false};
}

/* Attach debris to drum */
function attachDebrisToDrum(obj, collision) {
  obj.attached = true;
  // compute angle relative to drum center
  // angle in degrees around ellipse surface approximate by atan2(ly,lx)
  let angle = Math.atan2(collision.ly, collision.lx) * 180 / Math.PI;
  obj.attachedAngle = angle;
  // compute relative angle offset so when drum rotates the item moves
  attachedDebris.push(obj);
}

/* Detach debris: drop into collector */
function detachAllToCollector() {
  // For each attached debris, animate to fall vertically into collector center
  const collectorCenter = {x:480, y:330+20};
  attachedDebris.forEach(obj=>{
    obj.attached = false;
    // animate: set target to collector center, give small random offset
    const targetX = collectorCenter.x + (Math.random()*80 - 40);
    const targetY = collectorCenter.y + (Math.random()*20 - 0);
    // set a direct animation using attributes over time: we'll set vx/vy to reach target
    const dx = targetX - obj.cx;
    const dy = targetY - obj.cy;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const speed = 220 + Math.random()*120; // px/s
    obj.vx = dx / dist * speed;
    obj.vy = dy / dist * speed;
    // mark as inCollector when close
    obj.fallingToCollector = true;
  });
  attachedDebris = [];
}

/* Remove collected debris: when in collector and user triggers lift, move into bin and remove */
function collectIntoBin() {
  // Count items in collector (those with fallingToCollector and inside collector bounds)
  const itemsInCollector = debrisObjects.filter(o=>o.inCollector);
  collectorCount += itemsInCollector.length;
  // animate them to move to bin position (upper right of scene) then remove
  const binPos = {x:900, y:110};
  itemsInCollector.forEach((o,idx)=>{
    o.inCollector = false;
    o.vx = (binPos.x - o.cx) / 0.6; // will reach in ~600ms
    o.vy = (binPos.y - o.cy) / 0.6;
    o.toBeRemoved = true;
  });
}

/* After removal, tidy objects */
function cleanupRemoved() {
  const survivors = [];
  debrisObjects.forEach(o=>{
    if (o.toBeRemoved) {
      // remove element after it leaves scene
      setTimeout(()=>{ if (o.el && o.el.parentNode) o.el.parentNode.removeChild(o.el); }, 700);
    } else {
      survivors.push(o);
    }
  });
  debrisObjects = survivors;
}

/* Update function for animation */
function animate(time) {
  if (!lastTime) lastTime = time;
  const dt = (time - lastTime) / 1000; // seconds
  lastTime = time;

  // rotate drum if speed non-zero
  if (drumSpeed !== 0) {
    drumRotation = (drumRotation + drumSpeed * dt) % 360;
    drumGroup.setAttribute('transform', `translate(480,250) rotate(${drumRotation-18})`);
  } else {
    // ensure position remains consistent if rotation stopped
    drumGroup.setAttribute('transform', `translate(480,250) rotate(${drumRotation-18})`);
  }

  // Move slits relative rotation to keep slits visually rotating (they are children so rotate via parent)
  // Slits created in local drum coords. They rotate with group.

  // Move debris
  for (let obj of debrisObjects) {
    if (obj.attached) {
      // compute position on drum surface according to attachedAngle and drumRotation
      // We'll compute local coordinates on ellipse using angle (theta)
      const theta = (obj.attachedAngle + drumRotation) * Math.PI/180;
      const rx = 200, ry = 70;
      const lx = Math.cos(theta) * rx * 0.95; // slightly inward
      const ly = Math.sin(theta) * ry * 0.95;
      // transform back to global coords (apply group rotation of -18 then translate)
      const groupAngle = -18 * Math.PI/180;
      // rotate by group rotation: p' = R(groupAngle) * [lx,ly]
      const cosG = Math.cos(groupAngle);
      const sinG = Math.sin(groupAngle);
      const gx = cosG * lx - sinG * ly;
      const gy = sinG * lx + cosG * ly;
      obj.cx = 480 + gx;
      obj.cy = 250 + gy;
      updateDebrisElement(obj);
    } else if (obj.fallingToCollector) {
      // move by velocity
      obj.cx += obj.vx * dt;
      obj.cy += obj.vy * dt;
      // slow down and mark inside collector if reached
      // collector bounds: x in [260,700], y >= 330
      if (obj.cy > 330 && obj.cx > 260 && obj.cx < 700) {
        obj.vx = 0;
        obj.vy = 0;
        obj.fallingToCollector = false;
        obj.inCollector = true;
        obj.cx = Math.max(270, Math.min(700, obj.cx));
        obj.cy = 350 + Math.random()*12;
      }
      updateDebrisElement(obj);
    } else if (obj.toBeRemoved) {
      // moving to bin, apply velocity then fade
      obj.cx += obj.vx * dt;
      obj.cy += obj.vy * dt;
      updateDebrisElement(obj);
      // slight shrink
      obj.el.setAttribute('opacity', Math.max(0, 1 - 0.8*(Math.abs(obj.cx - 900)/400)));
    } else {
      // general drift with water flow
      obj.cx += obj.vx * dt;
      // small vertical bobbing
      obj.cy += Math.sin((time+obj.id*100)/400 + obj.id) * 0.5;
      updateDebrisElement(obj);

      // Detect collision with drum surface
      const col = checkDebrisCollision(obj);
      if (col.hit) {
        // attach at current position
        attachDebrisToDrum(obj, col);
      } else {
        // if beyond right bounds, remove element (it left the scene)
        if (obj.cx > 980) {
          if (obj.el && obj.el.parentNode) obj.el.parentNode.removeChild(obj.el);
          obj.toBeRemoved = true; // mark to be cleaned
        }
      }
    }
  }

  // Remove flagged objects from array
  const alive = debrisObjects.filter(o=> !o.toBeRemoved);
  if (alive.length !== debrisObjects.length) {
    debrisObjects = alive;
  }

  // Occasionally spawn debris based on time
  if (Math.random() < 0.02) spawnDebris();

  window.requestAnimationFrame(animate);
}

/* Start animation loop */
window.requestAnimationFrame(animate);

/* Buttons and interactive elements (IF-THEN logic implemented via clickCounts) */
const btnToggleDrum = document.getElementById('btnToggleDrum');
const btnLift = document.getElementById('btnLift');

btnToggleDrum.addEventListener('click', ()=> {
  handleDrumClick();
});
drum.addEventListener('click', ()=> {
  handleDrumClick();
});
controlBox.addEventListener('click', (e)=> {
  e.stopPropagation();
  handleControlClick();
});
document.getElementById('person').addEventListener('click', ()=>{
  handlePersonClick();
});
zoom.addEventListener('click', ()=>{
  handleZoomClick();
});

/* IF-THEN style handlers for drum */
function handleDrumClick() {
  clickCounts.drum++;
  if (clickCounts.drum === 1) {
    // then_first: start slow rotation
    drumSpeed = 26; drumState = 'slow';
    btnToggleDrum.textContent = 'Brzo okretanje';
    showTemporaryTooltip('Bubanj se pokreće (sporo).', 1300);
  } else {
    // then_next: cycle through a few actions: fast -> slow -> stop -> fast ...
    if (drumState === 'slow') {
      drumSpeed = 120; drumState = 'fast';
      btnToggleDrum.textContent = 'Utišaj bubanj';
      showTemporaryTooltip('Bubanj ubrzava (brzo).', 1100);
    } else if (drumState === 'fast') {
      drumSpeed = 0; drumState = 'stopped';
      btnToggleDrum.textContent = 'Pokreni bubanj';
      showTemporaryTooltip('Bubanj zaustavljen.', 1000);
    } else {
      drumSpeed = 26; drumState = 'slow';
      btnToggleDrum.textContent = 'Brzo okretanje';
      showTemporaryTooltip('Bubanj se pokreće (sporo).', 1100);
    }
  }
}

/* IF-THEN for control box: lift / empty collector */
function handleControlClick() {
  clickCounts.control++;
  if (clickCounts.control === 1) {
    // then_first: drop attached debris into collector (simulate cleaning lamela)
    detachAllToCollector();
    showTemporaryTooltip('Mehanizam skida otpad s bubnja i pusta ga u kolektor.', 1600);
  } else {
    // then_next: second click empties collector into bin; subsequent clicks toggle lifting mechanism
    // Simulate lifting: move items in collector to bin
    collectIntoBin();
    cleanupRemoved();
    showTemporaryTooltip('Kolektor se prazni u kontejner mehanizmom.', 1400);
    // reset counter every two clicks to allow repeated cycles
    if (clickCounts.control >= 2) clickCounts.control = 0;
  }
}

/* IF-THEN for person click: show info about monitoring */
function handlePersonClick() {
  clickCounts.person++;
  if (clickCounts.person === 1) {
    showTemporaryTooltip('Operator nadgleda rad i signalizira održavanje ako je potrebno.', 1800);
  } else {
    showTemporaryTooltip('Operator može zaustaviti mašinu u slučaju zastoja.', 1600);
    clickCounts.person = 0;
  }
}

/* IF-THEN for zoom detail */
function handleZoomClick() {
  clickCounts.zoom++;
  if (clickCounts.zoom === 1) {
    // then_first: show zoom detail overlay
    showZoomDetail(true);
    showTemporaryTooltip('Uvećani prikaz: čestice zaustavljene na lamelama.', 1500);
  } else {
    // then_next: hide
    showZoomDetail(false);
    clickCounts.zoom = 0;
  }
}

/* show/hide zoom detail content */
function showZoomDetail(show) {
  if (show) {
    zoomDetail.setAttribute('opacity', '1');
    // populate zoom content with a simplified static illustration of particles stopped on slats
    zoomContent.innerHTML = '';
    // draw lamella lines
    for (let i=0;i<6;i++) {
      const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
      rect.setAttribute('x', i*18);
      rect.setAttribute('y', 20);
      rect.setAttribute('width', 8);
      rect.setAttribute('height', 60);
      rect.setAttribute('fill','#bfc9cf');
      zoomContent.appendChild(rect);
      // add some particles caught between lamella
      const p = document.createElementNS('http://www.w3.org/2000/svg','circle');
      p.setAttribute('cx', i*18 + 12 + (i%2? -3:3));
      p.setAttribute('cy', 10 + (i%2? 18:12));
      p.setAttribute('r', 6 - (i%3));
      p.setAttribute('fill','#8f6b4a');
      zoomContent.appendChild(p);
    }
  } else {
    zoomDetail.setAttribute('opacity','0');
  }
}

/* Tooltip helper */
function showTemporaryTooltip(text, duration=1200) {
  tooltip.style.display = 'block';
  tooltip.textContent = text;
  tooltip.style.left = (window.innerWidth/2 - 120) + 'px';
  tooltip.style.top = '70px';
  setTimeout(()=>{ tooltip.style.display = 'none'; }, duration);
}

/* spawn initial debris to match initial description */
for (let i=0;i<8;i++) spawnDebris();

/* small interactive hover tooltips */
svg.addEventListener('mousemove', (e)=>{
  const pt = svg.createSVGPoint();
  pt.x = e.clientX; pt.y = e.clientY;
  const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
  // show helpful tip when near elements
  const x = svgP.x, y = svgP.y;
  // proximity checks
  let tip = '';
  // over drum area
  const dx = x - 480, dy = y - 250;
  if ((dx*dx)/(200*200) + (dy*dy)/(70*70) <= 1.2) tip = 'Klik na bubanj za kontrolu rotacije';
  // over control box
  const cbx = 720, cby = 70;
  if (x > 690 && x < 770 && y > 62 && y < 110) tip = 'Klik na upravljač za podizanje otpada';
  // zoom
  if (Math.hypot(x-880,y-80) < 60) tip = 'Klik za uvećani prikaz';
  // person
  if (Math.hypot(x-820,y-230) < 24) tip = 'Klik na operatera';
  if (tip) {
    tooltip.style.display = 'block';
    tooltip.textContent = tip;
    tooltip.style.left = (e.clientX + 12) + 'px';
    tooltip.style.top = (e.clientY + 12) + 'px';
  } else {
    tooltip.style.display = 'none';
  }
});

/* Hide tooltip on leave */
svg.addEventListener('mouseleave', ()=>{ tooltip.style.display = 'none'; });

/* Button shortcuts that mirror elements */
btnLift.addEventListener('click', ()=>{
  // simulate clicking control box
  controlBox.dispatchEvent(new Event('click'));
});

/* Make sure page is interactive even if no explicit interactions provided in JSON:
   - clicking different objects cycles through defined then_first and then_next sequences (tracked above)
*/

/* Final small polish: animate water pattern by shifting pattern via viewbox translation */
let waveOffset = 0;
function animateWaves() {
  waveOffset = (waveOffset + 1.4) % 60;
  const waveRect = document.querySelector('#scene rect[fill="url(#wavePattern)"]');
  if (waveRect) {
    // emulate movement by adjusting pattern transform via style
    waveRect.setAttribute('transform', `translate(${waveOffset},0)`);
  }
  requestAnimationFrame(animateWaves);
}
animateWaves();

</script>
</body>
</html>