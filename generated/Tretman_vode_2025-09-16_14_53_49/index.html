<!DOCTYPE html>
<html lang="sr">
<head>
  <meta charset="utf-8" />
  <title>Tretman vode</title>
  <style>
    html,body { height:100%; margin:0; font-family: Arial, Helvetica, sans-serif; background: #f4f7fb; color:#123; }
    #container { display:flex; flex-direction:column; align-items:center; padding:14px; }
    h1 { margin:6px 0 4px 0; font-size:28px; color:#0b3954; }
    p.description { max-width:900px; margin:0 0 12px 0; line-height:1.4; color:#133; }
    #sketch-holder { background: white; border-radius:8px; box-shadow: 0 6px 18px rgba(10,30,60,0.12); padding:10px; }
    .controls { margin-top:8px; display:flex; gap:12px; align-items:center; }
    .hint { font-size:13px; color:#345; background:#eef6ff; padding:8px 10px; border-radius:6px; border:1px solid rgba(15,70,120,0.06); }
    .counter { font-size:13px; color:#444; padding:6px 10px; background:#fff7; border-radius:6px; border:1px solid rgba(0,0,0,0.04); }
    footer.note { margin-top:8px; font-size:12px; color:#466; }
    /* small responsive */
    @media (max-width:940px){
      #sketch-holder canvas { max-width: 100%; height:auto !important; }
      p.description { padding:0 12px; }
    }
  </style>
  <!-- audience: Studenti trece godine -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
</head>
<body>
  <div id="container">
    <h1>Tretman vode</h1>
    <p class="description">
      Na slici je prikazan rezervoar s vodom i nagnutom metalnom rešetkom koja odvaja krupnije čestice iz protoka vode. Voda prolazi kroz uske proreze rešetke, dok se čvrsti otpad zadržava na lamelama.
      Iznad rešetke se vidi kućica s mehanizmom koji podiže i skida uhvaćeni otpad. U uvećanom krugu jasno su prikazane uhvaćene čestice i način kako se zaustavljaju na rešetci.
      Interaktivno istražite: kliknite na kućicu da pokrenete podizanje otpada, kliknite na rešetku da pogledate detalje ili očistite, i koristite uvećanje za pregled čestica.
    </p>

    <div id="sketch-holder"></div>

    <div class="controls">
      <div class="hint">Klikovi: kućica = podizanje/zaustavljanje | rešetka = naglasiti / očistiti | uvećanje = prikaz detalja</div>
      <div class="counter" id="stuck-count">Uhvaćene čestice: 0</div>
      <div class="counter" id="lift-status">Mehanizam: zaustavljen</div>
    </div>
    <div class="controls" style="margin-top:6px;">
      <div class="hint">Broji se prvo i naredna ponašanja: prvi klik aktivira početnu radnju, naredni klikovi menjaju ponašanje dalje.</div>
    </div>

    <footer class="note">Interaktivni prikaz: kliknite direktno na objekte na platnu (kućica, rešetka, uvećani krug).</footer>
  </div>

  <script>
    // Tretman vode - interaktivna p5.js scena
    // Publika (komentar): Studenti trece godine

    let canvasW = 900, canvasH = 600;
    let particles = [];
    let stuckParticles = [];
    let maxParticles = 80;
    let spawnTimer = 0;

    // Screen (rešetka) parameters
    const pivot = { x: 520, y: 150 }; // top pivot of the inclined screen (in canvas coords)
    const screenAngle = -28 * Math.PI/180; // radians (negative = tilt left-up)
    const screenLen = 420;
    const slatWidth = 18; // thickness of lamella
    const gap = 28; // opening between lamellae (where water passes)
    const slatSpacing = slatWidth + gap;
    const slatCount = Math.floor(screenLen / slatSpacing);

    // Positions for cabin and bin
    const cabin = { x: pivot.x - 40, y: pivot.y - 70, w: 90, h: 55 };
    const bin = { x: pivot.x + screenLen * Math.cos(screenAngle) + 50, y: pivot.y + screenLen * Math.sin(screenAngle) - 20, w: 70, h: 50 };

    // Interaction tracking
    let clickCounts = {
      cabin: 0,
      screen: 0,
      magnifier: 0
    };

    // Cabin mechanism state
    let mechanism = {
      running: false,
      paused: false,
      liftProgress: 0, // 0..1 indicates lifting progression per cycle
      speed: 0.008
    };

    // Screen highlight
    let screenHighlight = {
      active: false,
      highlightTimer: 0
    };

    // Magnifier
    let magnifier = {
      x: 760, y: 420, r: 110,
      active: false,
      stateIndex: 0
    };

    // Animation params
    let t = 0;

    function setup(){
      const cnv = createCanvas(canvasW, canvasH);
      cnv.parent('sketch-holder');
      frameRate(60);
      // init particles
      for(let i=0;i<20;i++) spawnParticle(true);
      updateUI();
    }

    function spawnParticle(initial=false){
      if(particles.length >= maxParticles) return;
      // spawn on left side moving right-down slightly
      let x = random(40, 140);
      let y = random(180, 420);
      let size = random(6, 12);
      let vx = random(0.6, 1.4) + random(-0.2,0.2) * (initial?0.1:1);
      let vy = random(-0.12,0.12);
      particles.push({ x, y, vx, vy, size, stuck:false, stuckOn:null, color: color(40,100,180,170) });
    }

    function draw(){
      background(245, 248, 253);
      t += 1/60;

      // draw water tank and environment
      drawTank();
      drawScreen();
      drawCabinAndMechanism();
      drawParticles();
      drawBin();
      drawMagnifier();

      // spawn particles occasionally
      spawnTimer += 1/60;
      if(spawnTimer > 0.28){
        spawnTimer = 0;
        if(random() < 0.85) spawnParticle();
      }

      // update mechanism lift if running
      if(mechanism.running && !mechanism.paused){
        mechanism.liftProgress += mechanism.speed;
        if(mechanism.liftProgress >= 1){
          // perform one lift cycle: move some stuck particles into bin
          performLiftCycle();
          mechanism.liftProgress = 0;
        }
      }

      // screen highlight decay
      if(screenHighlight.active){
        screenHighlight.highlightTimer += deltaTime / 1000;
        if(screenHighlight.highlightTimer > 2.0){
          screenHighlight.active = false;
          screenHighlight.highlightTimer = 0;
        }
      }

      updateUI();
    }

    function drawTank(){
      // water area
      push();
      noStroke();
      fill(210,235,255);
      rect(20,130,430,380,6);

      // bottom pipe/flow indicator
      stroke(30,80,120,160);
      strokeWeight(2);
      line(20,130+380,20+430,130+380);

      // label
      noStroke();
      fill(18,40,70);
      textSize(14);
      textAlign(LEFT, TOP);
      text("Rezervoar", 28, 136);
      pop();
    }

    function drawScreen(){
      push();
      translate(pivot.x, pivot.y);
      rotate(screenAngle);
      // draw slats
      for(let i=0;i<slatCount;i++){
        let sx = 0 + i * slatSpacing;
        let sy = -8;
        if(screenHighlight.active){
          fill(200,70,50);
          stroke(140,40,40);
        } else {
          fill(190,190,200);
          stroke(120);
        }
        rect(sx, sy, slatWidth, 420, 3);
      }
      // supporting frame
      stroke(90);
      strokeWeight(6);
      noFill();
      rect(-12, -20, 10, 440, 4);
      pop();

      // slanted line to show flow direction
      push();
      stroke(60,100,160,120);
      strokeWeight(2);
      let start = { x: pivot.x - 40, y: pivot.y + 18 };
      line(start.x - 120, start.y + 40, pivot.x + screenLen * Math.cos(screenAngle) + 120, pivot.y + screenLen * Math.sin(screenAngle) + 60);
      pop();
    }

    function drawCabinAndMechanism(){
      // cabin box
      push();
      fill(235,245,250);
      stroke(40,80,120);
      strokeWeight(1.5);
      rect(cabin.x, cabin.y, cabin.w, cabin.h, 6);
      // roof
      fill(20,70,110);
      triangle(cabin.x-4, cabin.y, cabin.x + cabin.w/2, cabin.y-20, cabin.x + cabin.w +4, cabin.y);
      // small window
      fill(180,220,240);
      noStroke();
      rect(cabin.x + 12, cabin.y + 12, 26, 18, 3);
      // crane cable
      stroke(70,70,70);
      strokeWeight(3);
      let attachX = pivot.x - 6;
      let attachY = pivot.y - 6;
      line(cabin.x + cabin.w/2, cabin.y + cabin.h, attachX, attachY);
      // grabber animation: draw a simple hook that moves along liftProgress if running
      let grabYoff = map(mechanism.liftProgress, 0,1, -10, 60);
      if(mechanism.running){
        stroke(40,40,40);
        strokeWeight(3);
        line(attachX, attachY, attachX + 6, attachY + 8 + grabYoff);
        line(attachX + 6, attachY + 8 + grabYoff, attachX + 18, attachY + 8 + grabYoff);
        fill(80,40,20);
        noStroke();
        rect(attachX + 18, attachY + 2 + grabYoff, 10, 8, 2);
      }
      // cabin label
      noStroke();
      fill(6,40,80);
      textSize(12);
      textAlign(LEFT, CENTER);
      text("Kućica mehanizma", cabin.x + 6, cabin.y + cabin.h + 14);
      pop();
    }

    function drawBin(){
      push();
      fill(230,230,230);
      stroke(90);
      rect(bin.x, bin.y, bin.w, bin.h, 6);
      // label
      noStroke();
      fill(50);
      textSize(12);
      textAlign(CENTER);
      text("Smeće", bin.x + bin.w/2, bin.y + bin.h + 14);
      pop();
    }

    function drawParticles(){
      // update and draw particles
      for(let p of particles){
        if(!p.stuck){
          // advect by velocity, add some small sinusoidal to mimic turbulence
          p.x += p.vx;
          p.y += p.vy + sin((p.x + t*10) * 0.03) * 0.02;
          // check collision with screen lamella geometry
          if(checkCollisionWithScreen(p)){
            // mark as stuck at the slat index and position
            p.stuck = true;
            p.color = color(180,40,40,220);
            stuckParticles.push(p);
          }
        }else{
          // remain in place (unless lift moves it)
          // no op; position already snapped to slat
        }
      }

      // remove particles that reached bin (they will be moved to removed list)
      // draw moving ones behind screen
      // draw particles sorted by x so deeper ones appear behind
      particles.sort((a,b)=>a.x - b.x);

      for(let p of particles){
        noStroke();
        if(p.stuck){
          // draw on top of slat contour
          fill(red(p.color), green(p.color), blue(p.color), alpha(p.color));
        } else {
          fill(40,100,180,180);
        }
        ellipse(p.x, p.y, p.size);
      }
    }

    function checkCollisionWithScreen(p){
      // transform point into screen-local coordinates by rotating around pivot by -angle
      // so that the screen aligns horizontally
      let s = rotatePoint({x:p.x, y:p.y}, pivot, -screenAngle); // rotate by positive angle to align
      // screen local x coordinate relative to pivot
      let localX = s.x - pivot.x;
      let localY = s.y - pivot.y;
      // if localX in [0, screenLen] and localY between -30..420 (covers slat height)
      if(localX >= 0 && localX <= screenLen && localY > -30 && localY < 420){
        // compute which band index along x
        let idx = Math.floor(localX / slatSpacing);
        if(idx >= 0 && idx < slatCount){
          // position within this band
          let bandPos = localX - idx * slatSpacing;
          if(bandPos <= slatWidth){ // hits the slat (solid)
            // snap particle to the slat surface: compute slat center in world coords
            let slatLocalX = idx * slatSpacing + slatWidth/2;
            // set local y to a position on slat (we place it slightly inside slat surface)
            let slatLocalY = 40 + (localY % 60); // just a stable offset to visually distribute
            let world = rotatePoint({x: pivot.x + slatLocalX, y: pivot.y + slatLocalY}, pivot, screenAngle);
            p.x = world.x + random(-1,1);
            p.y = world.y + random(-1,1);
            p.stuckOn = { idx: idx, localX: slatLocalX, localY: slatLocalY };
            return true;
          }
        }
      }
      return false;
    }

    function rotatePoint(pt, center, angle){
      // rotates pt around center by angle (radians), clockwise positive
      let dx = pt.x - center.x;
      let dy = pt.y - center.y;
      let rx = dx * cos(angle) - dy * sin(angle);
      let ry = dx * sin(angle) + dy * cos(angle);
      return { x: center.x + rx, y: center.y + ry };
    }

    function performLiftCycle(){
      // Lift a subset of stuck particles from near top to bin.
      if(stuckParticles.length == 0) return;
      // choose those closest to top (smallest stuckOn.localX)
      stuckParticles.sort((a,b)=>a.stuckOn.localX - b.stuckOn.localX);
      // pick up to 8 particles
      let toMove = stuckParticles.splice(0, min(8, stuckParticles.length));
      for(let p of toMove){
        // animate to bin via simple tween using p._moveProg
        p._movingToBin = true;
        p._moveProg = 0;
        p._startPos = { x: p.x, y: p.y };
        p._endPos = { x: bin.x + bin.w/2 + random(-10,10), y: bin.y + random(6, bin.h - 8) };
      }
      // move them over time by adding to particles list if not present
      // We'll update their positions in a separate loop
      animateMovingParticles();
    }

    function animateMovingParticles(){
      // This function will animate particles flagged _movingToBin each frame by attaching to draw loop
      // We'll iterate through moving ones and update them
      // Use setInterval-like via p5 draw loop by setting a flag; here we ensure per-frame update
    }

    // override draw loop to update moving particles positions
    // We'll add updates inside draw() after main logic by using requestAnimationFrame cycle; but we already in draw()
    // So add updating moving particles here by scanning particles
    // We'll implement as separate small function called inside draw()
    // To do that, modify draw() to call updateMovingParticles(); (we'll just define it and then call it)
    function updateMovingParticles(){
      let removed = [];
      for(let i=particles.length-1;i>=0;i--){
        let p = particles[i];
        if(p._movingToBin){
          p._moveProg += 0.02; // speed of travel
          let t = constrain(p._moveProg, 0, 1);
          // ease
          let ease = t<0.5? 2*t*t : -1 + (4 - 2*t)*t;
          p.x = lerp(p._startPos.x, p._endPos.x, ease);
          p.y = lerp(p._startPos.y, p._endPos.y, ease);
          // draw with small offset
          if(t >= 1){
            // remove particle from particles array (it reached bin)
            particles.splice(i,1);
          }
        }
      }
      // ensure stuckParticles sync: remove items that have been moved
      stuckParticles = stuckParticles.filter(sp => !sp._movingToBin);
    }

    // small helper to read color components
    function red(c){ return Math.floor(c.levels ? c.levels[0] : c[0]); }
    function green(c){ return Math.floor(c.levels ? c.levels[1] : c[1]); }
    function blue(c){ return Math.floor(c.levels ? c.levels[2] : c[2]); }
    function alpha(c){ return Math.floor(c.levels ? c.levels[3] : 255); }

    // integrate updateMovingParticles into main draw by wrapping draw function pointer
    // Instead of complicated rebind, simply call updateMovingParticles at end of draw cycle using p5 'redraw' flow
    // So we add call here using requestAnimationFrame-like: implement by setting a p5 post-draw hook via setTimeout(0)
    // Simpler: incorporate updateMovingParticles at top-level call by adding it inside draw function above.
    // To keep code coherent, we'll monkey-patch draw by adding call below using p5's built-in loop; but already in draw() we can call updateMovingParticles.
    // So add a small trick: define an alias of original draw in a closure. But for simplicity, append updateMovingParticles at end of draw via function re-definition.
    // To achieve that, re-define draw to include updateMovingParticles: We'll implement updateMovingParticles call at bottom of draw via setTimeout 0 won't help. Instead, hack: use p5's draw event by adding an event listener - but p5 doesn't allow easily.
    // Instead, to keep consistent, simply call updateMovingParticles inside draw earlier. So modify draw above: (We will now add the call here.)
    // Because of limitations in this inline code block, call updateMovingParticles each frame via setTimeout is unnecessary. We'll add a small interval to process moving particles smoothly:
    setInterval(() => {
      // move _movingToBin particle positions gradually over time
      for(let p of particles){
        if(p._movingToBin){
          p._moveProg += 0.02;
          let t = constrain(p._moveProg, 0, 1);
          let ease = t<0.5? 2*t*t : -1 + (4 - 2*t)*t;
          p.x = lerp(p._startPos.x, p._endPos.x, ease);
          p.y = lerp(p._startPos.y, p._endPos.y, ease);
        }
      }
      // cleanup fully moved
      for(let i=particles.length-1;i>=0;i--){
        let p = particles[i];
        if(p._movingToBin && p._moveProg >= 1){
          particles.splice(i,1);
        }
      }
      // sync stuckParticles
      stuckParticles = stuckParticles.filter(sp => !sp._movingToBin);
    }, 40);

    // helper to update UI counters
    function updateUI(){
      const stuckEl = document.getElementById('stuck-count');
      stuckEl.innerText = "Uhvaćene čestice: " + stuckParticles.length;
      const liftEl = document.getElementById('lift-status');
      liftEl.innerText = "Mehanizam: " + (mechanism.running ? (mechanism.paused ? "pauziran" : "pokreće se") : "zaustavljen");
    }

    function drawMagnifier(){
      // magnifier circle at magnifier.x,y with r
      push();
      translate(0,0);
      stroke(80,120,160);
      strokeWeight(2);
      fill(255,255,255, 180);
      ellipse(magnifier.x, magnifier.y, magnifier.r*2 + 6);
      // draw inner view if active
      if(magnifier.active){
        // show a zoom of the screen pivot area
        let zoomCenter = { x: pivot.x + 60 * cos(screenAngle), y: pivot.y + 60 * sin(screenAngle) + 20 };
        // draw inner content using a clip
        push();
        // create clipped mask
        drawingContext.save();
        drawingContext.beginPath();
        drawingContext.arc(magnifier.x, magnifier.y, magnifier.r, 0, Math.PI*2);
        drawingContext.clip();

        // background
        noStroke();
        fill(245);
        rect(magnifier.x - magnifier.r, magnifier.y - magnifier.r, magnifier.r*2, magnifier.r*2);

        // draw enlarged view of a portion around zoomCenter
        let zoom = 2.6;
        push();
        translate(magnifier.x - (zoomCenter.x - magnifier.r/zoom), magnifier.y - (zoomCenter.y - magnifier.r/zoom));
        scale(zoom);
        // re-draw a simplified scene portion
        // small section of slats
        push();
        translate(pivot.x, pivot.y);
        rotate(screenAngle);
        noStroke();
        for(let i=1;i<6;i++){
          fill(200);
          rect(i * slatSpacing, -8, slatWidth, 120, 3);
        }
        pop();

        // draw stuck particles near pivot magnified
        for(let p of stuckParticles){
          // only show near pivot
          let d = dist(p.x, p.y, pivot.x + 60 * cos(screenAngle), pivot.y + 60 * sin(screenAngle));
          if(d < 120){
            fill(200,70,50);
            noStroke();
            ellipse(p.x, p.y, p.size*2.6);
          }
        }

        // arrows showing capture
        if(magnifier.stateIndex === 1 || magnifier.stateIndex === 2){
          stroke(10,120,200);
          strokeWeight(3);
          noFill();
          // arrow line
          line(zoomCenter.x - 40, zoomCenter.y - 20, zoomCenter.x - 12, zoomCenter.y - 8);
          line(zoomCenter.x - 42, zoomCenter.y - 18, zoomCenter.x - 24, zoomCenter.y - 10);
        }
        pop();

        drawingContext.restore();
        pop();

        // caption
        noStroke();
        fill(12,40,60);
        textSize(12);
        textAlign(CENTER);
        text("Uvećani prikaz rešetke", magnifier.x, magnifier.y + magnifier.r - 12);
      } else {
        noStroke();
        fill(12,40,60);
        textSize(11);
        textAlign(CENTER);
        text("Klik za uvećanje", magnifier.x, magnifier.y + magnifier.r - 14);
      }
      pop();
    }

    function mousePressed(){
      // check click on cabin
      if(mouseX >= cabin.x && mouseX <= cabin.x + cabin.w && mouseY >= cabin.y && mouseY <= cabin.y + cabin.h){
        clickCounts.cabin++;
        handleCabinClick(clickCounts.cabin);
        return;
      }
      // check click on screen area: approximate by bounding box around slats
      // compute bounding poly of screen
      let s1 = rotatePoint({x: pivot.x + 0, y: pivot.y - 10}, {x:0,y:0}, 0); // not used
      // quick bounding box: compute four corners of the rotated rectangle
      let p0 = { x: pivot.x, y: pivot.y - 20 };
      let p1 = { x: pivot.x + screenLen * cos(screenAngle), y: pivot.y + screenLen * sin(screenAngle) - 20 };
      let p2 = { x: pivot.x + screenLen * cos(screenAngle), y: pivot.y + screenLen * sin(screenAngle) + 420 };
      let p3 = { x: pivot.x, y: pivot.y + 420 };
      if(pointInQuad({x:mouseX, y:mouseY}, p0,p1,p2,p3)){
        clickCounts.screen++;
        handleScreenClick(clickCounts.screen);
        return;
      }
      // check magnifier
      let md = dist(mouseX, mouseY, magnifier.x, magnifier.y);
      if(md <= magnifier.r + 6){
        clickCounts.magnifier++;
        handleMagnifierClick(clickCounts.magnifier);
        return;
      }
    }

    function pointInQuad(pt,a,b,c,d){
      // using winding or barycentric approach: split into two triangles
      return pointInTriangle(pt,a,b,c) || pointInTriangle(pt,a,c,d);
    }
    function pointInTriangle(pt,a,b,c){
      let area = (a.x - pt.x)*(b.y - pt.y) - (b.x - pt.x)*(a.y - pt.y);
      let area2 = (b.x - pt.x)*(c.y - pt.y) - (c.x - pt.x)*(b.y - pt.y);
      let area3 = (c.x - pt.x)*(a.y - pt.y) - (a.x - pt.x)*(c.y - pt.y);
      let hasNeg = (area < 0) || (area2 < 0) || (area3 < 0);
      let hasPos = (area > 0) || (area2 > 0) || (area3 > 0);
      return !(hasNeg && hasPos);
    }

    // Interaction handlers implementing IF-THEN-FIRST and THEN-NEXT sequences
    function handleCabinClick(count){
      if(count === 1){
        // then_first: start mechanism running (lift cycles)
        mechanism.running = true;
        mechanism.paused = false;
      } else {
        // then_next: toggle pause / resume, every further click toggles paused
        mechanism.paused = !mechanism.paused;
      }
    }

    function handleScreenClick(count){
      if(count === 1){
        // then_first: highlight screen and show explanation (toggle highlight)
        screenHighlight.active = true;
        screenHighlight.highlightTimer = 0;
      } else {
        // then_next sequence: on each subsequent click, perform cleaning sweep:
        // remove up to N stuck particles from the near-surface (simulate scrapper)
        if(stuckParticles.length > 0){
          let removeN = min(6, stuckParticles.length);
          for(let i=0;i<removeN;i++){
            let p = stuckParticles.shift();
            // animate particle removal by moving it to bin path
            p._movingToBin = true;
            p._moveProg = 0;
            p._startPos = { x: p.x, y: p.y };
            p._endPos = { x: bin.x + bin.w/2 + random(-10,10), y: bin.y + random(6, bin.h - 8) };
            // ensure it's still in main particles array (it is)
          }
        } else {
          // if nothing stuck, small nudge animation
          screenHighlight.active = true;
          screenHighlight.highlightTimer = 0;
        }
      }
    }

    function handleMagnifierClick(count){
      if(count === 1){
        // then_first: open magnifier
        magnifier.active = true;
        magnifier.stateIndex = 0;
      } else {
        // then_next: cycle through states: 0 -> 1 -> 2 -> 0
        magnifier.stateIndex = (magnifier.stateIndex + 1) % 3;
        if(magnifier.stateIndex === 0){
          magnifier.active = false;
        } else {
          magnifier.active = true;
        }
      }
    }

    // Utility wrappers
    function constrain(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function min(a,b){ return a < b ? a : b; }
  </script>
</body>
</html>