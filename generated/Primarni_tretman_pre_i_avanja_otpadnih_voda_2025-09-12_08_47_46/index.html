<!doctype html>
<html lang="sr">
<head>
  <meta charset="utf-8">
  <title>Primarni tretman prečićavanja otpadnih voda</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <style>
    html,body { height:100%; margin:0; font-family: Arial, Helvetica, sans-serif; background: #f3f6f8; color:#222; }
    .container { max-width:1100px; margin:18px auto; padding:16px; background:#fff; border-radius:10px; box-shadow:0 6px 20px rgba(30,40,50,0.08); }
    h1 { margin:6px 0 8px 0; font-size:24px; color:#0b4a6f; }
    p.description { margin:0 0 12px 0; color:#334; line-height:1.4; }
    #canvas-holder { border-radius:8px; overflow:hidden; background:linear-gradient(#e9f2fb,#f7fbff); padding:8px; }
    .controls { margin-top:10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    button { background:#0b6fa3; color:white; border:0; padding:8px 12px; border-radius:6px; cursor:pointer; font-weight:600; box-shadow:0 2px 6px rgba(11,111,163,0.18); }
    button.secondary { background:#7aa8c6; }
    .legend { margin-left:auto; font-size:13px; color:#375; display:flex; gap:12px; align-items:center; }
    .legend .item { display:flex; gap:6px; align-items:center; }
    .dot { width:14px; height:10px; border-radius:3px; }
    .dot.water { background:linear-gradient(#66b3ff,#2a9cff); border:1px solid rgba(30,140,220,0.2); }
    .dot.debris { background:linear-gradient(#8a5b3a,#6b3f2a); border:1px solid rgba(70,40,20,0.2); }
    .small { font-size:13px; color:#445; }
    /* canvas responsive container */
    #defaultCanvas0 { display:block; margin:8px auto; border-radius:6px; }
    footer.credit { margin-top:8px; font-size:12px; color:#6b7; text-align:right; }
  </style>
  <!-- audience: Student treće godine -->
</head>
<body>
  <div class="container">
    <h1>Primarni tretman prečićavanja otpadnih voda</h1>
    <p class="description">Grube rešetke za uklanjanje krupnih čestica iz otpadne vode. Interaktivna simulacija prikazuje protok vode kroz providnu cev, sitne čestice strujanja i krupne komade otpada (lišće, grane). Na polovini cevi postavljena je pod uglom druga cev sa rotirajućom rešetkom koja pešice odvaja i podiže krupni otpad. Klikom na elemente možete menjati brzinu rešetke, obeležiti otpad i pratiti proces filtracije.</p>

    <div id="canvas-holder"></div>

    <div class="controls">
      <button id="toggleFlow">Zaustavi tok</button>
      <button id="reset">Resetuj scenu</button>
      <button id="spawnDebris" class="secondary">Dodaj grubi otpad</button>
      <div class="legend">
        <div class="item"><div class="dot water"></div><div class="small">Voda / sitne čestice</div></div>
        <div class="item"><div class="dot debris"></div><div class="small">Grubi otpad (lišće, grane)</div></div>
      </div>
    </div>
    <div class="small" style="margin-top:8px;">Uputstvo: Kliknite na rešetku da promenite brzinu rotacije (prvi klik = ubrzaj, sledeći = uspori). Klikom na grubi otpad obeležavate ga ručno — prvi klik ga ističe (then_first), svaki sledeći klik menja njegovo stanje (then_next). Otpad koji dođe u kontakt sa rešetkom biće uhvaćen i podignut u kolektor.</div>
    <footer class="credit">Simulacija: interaktivna demonstracija primarnog tretmana</footer>
  </div>

<script>
/*
  JSON mapping (interpreted):
  title: page title shown above
  audience: Student treće godine (included as comment)
  description: shown as paragraph
  initial: visual initial state implemented below
  interactions: empty in input -> generic click-action mechanism is implemented:
    - Each interactive object (rake, debris) tracks clickCount.
    - then_first applied at first click; then_next is cycled on subsequent clicks.
*/

let canvasW = 1000, canvasH = 360;
let flowOn = true;
let waterParticles = [];
let debrisList = [];
let rake;
let flowSpeed = 1.6; // base speed of water particles and debris
let lastDebrisId = 0;
let gui = {};

function setup() {
  let cnv = createCanvas(canvasW, canvasH);
  cnv.parent('canvas-holder');
  angleMode(DEGREES);
  rectMode(CENTER);

  // create initial water particles
  for (let i=0;i<120;i++){
    waterParticles.push(new WaterParticle(random(-canvasW, canvasW), random(canvasH*0.28, canvasH*0.72)));
  }
  // create initial debris pieces
  for (let i=0;i<8;i++){
    debrisList.push(new Debris(random(-200, canvasW-60), random(canvasH*0.36, canvasH*0.66), random(0.9,1.4), random(['leaf','branch'])));
  }

  // position of main pipe: horizontally across center
  let pipe = {x:50, y:canvasH*0.5, w:canvasW-100, h:90};
  // rake position: at mid of pipe
  rake = new Rake(pipe.x + pipe.w*0.5, pipe.y - 10, -55, 110, pipe); // angle upward-left

  // GUI
  gui.toggleFlowBtn = select('#toggleFlow');
  gui.toggleFlowBtn.mousePressed(()=>{ flowOn = !flowOn; gui.toggleFlowBtn.html(flowOn? 'Zaustavi tok' : 'Pokreni tok'); });
  select('#reset').mousePressed(resetScene);
  select('#spawnDebris').mousePressed(()=>spawnDebris());

  // instruction to click items: mousePressed handled below
}

function spawnDebris(){
  debrisList.push(new Debris(-60, random(canvasH*0.36, canvasH*0.66), random(1.0,1.6), random(['leaf','branch'])));
}

// Reset
function resetScene(){
  waterParticles = [];
  debrisList = [];
  for (let i=0;i<120;i++){
    waterParticles.push(new WaterParticle(random(-canvasW, canvasW), random(canvasH*0.28, canvasH*0.72)));
  }
  for (let i=0;i<8;i++){
    debrisList.push(new Debris(random(-200, canvasW-60), random(canvasH*0.36, canvasH*0.66), random(0.9,1.4), random(['leaf','branch'])));
  }
  flowOn = true;
  gui.toggleFlowBtn.html('Zaustavi tok');
  rake.reset();
}

// Main draw
function draw(){
  background(250);
  drawBackground();

  drawPipes();

  // draw and update water particles (behind debris)
  for (let p of waterParticles){
    p.update();
    p.display();
  }

  // update rake
  rake.update();
  rake.display();

  // debris
  for (let d of debrisList){
    d.update();
    d.display();
    // check collision with rake region
    if (!d.caught && !d.removed && rake.detectCatch(d)){
      d.onCaughtByRake(rake);
    }
  }

  // remove debris fully removed (collected) after animation
  debrisList = debrisList.filter(d => !d.toBeDeleted);

  // overlay controls/instructions visuals (optional)
  drawProgress();
}

// Background gradient & subtle floor
function drawBackground(){
  noStroke();
  // top highlight
  fill(245, 251, 255);
  rect(width/2, height/2, width, height);
}

// Draw main transparent pipe and angled lifting pipe
function drawPipes(){
  push();
  translate(0,0);
  // main horizontal pipe
  let pipeX = 50, pipeY = height*0.5, pipeW = width-100, pipeH = 90;
  // outer rim
  stroke(100,150,170, 120);
  strokeWeight(3);
  fill(220,240,250,220);
  rect(pipeX + pipeW/2, pipeY, pipeW, pipeH, 14);
  // inner transparent wall
  noStroke();
  fill(255,255,255,120);
  rect(pipeX + pipeW/2, pipeY, pipeW-8, pipeH-12, 12);
  // small flow guide lines
  stroke(180,220,240,80);
  strokeWeight(1);
  for (let i=0;i<6;i++){
    line(pipeX + 10 + i*(pipeW-20)/5, pipeY-pipeH*0.33, pipeX + 10 + i*(pipeW-20)/5, pipeY+pipeH*0.33);
  }

  // angled rising pipe (collector) attached at mid
  let angPipeX = pipeX + pipeW*0.5;
  let angPipeY = pipeY - 8;
  let ang = rake.angle; // rake angle will match pipe angle
  push();
  translate(angPipeX, angPipeY);
  rotate(ang+90); // make pipe follow rake with slight orientation
  // pipe rectangle
  stroke(100,150,170,120);
  strokeWeight(3);
  fill(230,245,250,230);
  rect(0, -32, 18, 160, 8);
  // rim open top
  pop();

  pop();
}

// Draw progress / counters
function drawProgress(){
  push();
  fill(20,60,80,220);
  noStroke();
  textSize(13);
  let caught = debrisList.filter(d => d.caught && !d.toBeDeleted).length;
  text('Uklonjeno krupnog otpada: ' + caught, 18, 18);
  pop();
}

/* Classes */

class WaterParticle {
  constructor(x,y){
    this.x = x;
    this.y = y;
    this.r = random(1.8,3.2);
    this.speed = random(flowSpeed*0.8, flowSpeed*1.4);
    this.alpha = random(140,220);
  }
  update(){
    if (flowOn) this.x += this.speed;
    // wrap
    if (this.x > width + 30) this.x = -random(30, width*0.3);
    // slight vertical oscillation
    this.y += sin((frameCount+this.x)*0.01)*0.3;
  }
  display(){
    noStroke();
    fill(90,170,255, this.alpha);
    ellipse(this.x, this.y, this.r*2, this.r*1.6);
    // tiny sparkle
    fill(220,245,255, this.alpha*0.6);
    ellipse(this.x+this.r*0.2, this.y-this.r*0.2, this.r*0.8, this.r*0.5);
  }
}

class Debris {
  constructor(x,y,scale,type){
    this.id = ++lastDebrisId;
    this.x = x;
    this.y = y;
    this.baseY = y;
    this.scale = scale;
    this.type = type; // leaf or branch
    this.vx = random(0.6,1.8) * flowSpeed;
    this.vy = 0;
    this.rotation = random(-18,18);
    this.rotSpeed = random(-0.3,0.3);
    this.caught = false;
    this.removed = false;
    this.toBeDeleted = false;
    // click management
    this.clickCount = 0;
    this.states = ['normal']; // then_first + then_next simulated
    // Visual flags
    this.highlight = false;
    // path when caught
    this.catchProgress = 0; // 0..1
    this.catchPath = null; // array of points to animate along
  }
  update(){
    if (this.toBeDeleted) return;
    if (!this.caught && !this.removed){
      if (flowOn) this.x += this.vx * (frameRate() ? deltaTime/16 : 1);
      // slightly bob
      this.y = this.baseY + sin((this.x+this.id)*0.02)*6;
      this.rotation += this.rotSpeed;
    } else if (this.caught && !this.removed){
      // animate along catch path upward
      if (this.catchPath){
        this.catchProgress += 0.012 * (rake.rotationSpeedNormalized());
        if (this.catchProgress >= 1){
          this.catchProgress = 1;
          this.removed = true;
          // slight delay then mark deleted
          setTimeout(()=>{ this.toBeDeleted = true; }, 900);
        }
        // interpolate
        let idx = this.catchProgress * (this.catchPath.length-1);
        let i0 = floor(idx);
        let t = idx - i0;
        let p0 = this.catchPath[i0];
        let p1 = this.catchPath[min(i0+1,this.catchPath.length-1)];
        this.x = lerp(p0.x,p1.x,t);
        this.y = lerp(p0.y,p1.y,t);
        this.rotation += this.rotSpeed*3;
      }
    }
  }
  display(){
    push();
    translate(this.x, this.y);
    rotate(this.rotation);
    scale(this.scale);
    if (this.highlight){
      stroke(255,200,60,180);
      strokeWeight(2.2);
      fill(255,245,180,120);
      ellipse(0,0,50,32);
    }
    // draw type
    if (this.type === 'leaf'){
      noStroke();
      fill(90,140,60);
      ellipse(0,0,26,14);
      fill(60,110,40);
      triangle(-6,0, 6,0, 0,-12);
      stroke(50,90,30);
      strokeWeight(1);
      line(0,-12,0,8);
    } else {
      // branch
      noStroke();
      fill(110,70,40);
      rect(0,0,34,8,4);
      stroke(80,50,30);
      strokeWeight(2);
      line(-12,-4, -20,-10);
      line(10,-3, 18,-8);
    }
    // if removed show a faded label
    if (this.removed){
      noStroke();
      fill(255,255,255,180);
      rect(0,-20,70,18,8);
      fill(40,80,100);
      textSize(11);
      textAlign(CENTER, CENTER);
      text("Uklonjeno",0,-20);
    }
    pop();
  }
  // click handling called from global mousePressed if clicked on object
  onClick(){
    this.clickCount++;
    if (this.clickCount === 1){
      // then_first: highlight it to indicate manual tagging
      this.highlight = true;
      this.states.push('tagged');
    } else {
      // then_next: cycle between manual-removed / fragile states
      let step = (this.clickCount - 2) % 3;
      if (step === 0){
        // mark as to be manually removed (teleport to bin)
        this.removed = true;
        this.toBeDeleted = true;
      } else if (step === 1){
        // revert highlight
        this.highlight = false;
      } else {
        // mark fragile (changes color)
        this.highlight = true;
      }
    }
  }

  onCaughtByRake(rake){
    this.caught = true;
    // compute path along rake tines upward to collection point
    this.catchPath = rake.computeCatchPath({x:this.x,y:this.y});
    this.catchProgress = 0;
  }
}

class Rake {
  constructor(x,y,angleDeg,length, parentPipe){
    this.x = x;
    this.y = y;
    this.angle = angleDeg; // pointing upward-left typically
    this.length = length;
    this.parentPipe = parentPipe;
    this.rotation = 0; // rotation of rakebar about center
    this.baseRotSpeed = 0.6; // degrees per frame
    this.rotDirection = 1;
    this.rotating = true;
    this.clickCount = 0;
    this.rotationSpeedMultiplier = 1;
    this.tines = 8;
    this.tineSpacing = this.length / this.tines;
    this.grabZoneRadius = 48; // radius around tip where debris can be caught
  }
  update(){
    if (this.rotating){
      this.rotation += this.baseRotSpeed * this.rotationSpeedMultiplier * this.rotDirection;
    }
  }
  display(){
    push();
    translate(this.x, this.y);
    rotate(this.angle);
    // draw attachment flange
    noStroke();
    fill(160,200,220);
    ellipse(0,0,26,26);
    // draw pole
    stroke(110,150,170);
    strokeWeight(6);
    line(0,0, -this.length*0.12, -this.length*0.32);
    // draw rake arm: rotating bar with tines
    push();
    rotate(this.rotation);
    // bar
    stroke(80,100,120);
    strokeWeight(8);
    line(0,0, -this.length, 0);
    // tines
    for (let i=0;i<this.tines;i++){
      let tx = -i*(this.tineSpacing) - 10;
      let ty = 0;
      stroke(70,60,50);
      strokeWeight(3);
      line(tx,ty, tx, ty-16);
    }
    // a slight highlight on tip
    noStroke();
    fill(255,235,180,200);
    ellipse(-this.length,0,10,10);
    pop();

    // show small status text near rake
    noStroke();
    fill(30,60,80);
    textSize(12);
    textAlign(LEFT, CENTER);
    text('Rešetka', 10, -18);
    textSize(11);
    let spdLabel = this.rotationSpeedNormalized() * 100;
    text('Brzina: ' + nf(spdLabel,2,0) + '%', 10, -4);

    pop();
  }

  reset(){
    this.rotation = 0;
    this.clickCount = 0;
    this.rotationSpeedMultiplier = 1;
    this.rotating = true;
  }

  detectCatch(debris){
    // approximate catch when debris comes near rake tip in world coords and rake orientation is favorable
    // compute rake tip position
    let tip = this.tipPosition();
    let d = dist(debris.x, debris.y, tip.x, tip.y);
    if (d < this.grabZoneRadius && abs(normalizeAngle(this.rotation)) < 80){
      // also check relative angle so tines face incoming debris direction
      // probability factor based on rotation speed (faster sometimes better)
      return true;
    }
    return false;
  }

  tipPosition(){
    // tip in world coords: rake arm rotated by angle + rotation
    let ang = this.angle + this.rotation;
    let tx = this.x + cos(ang) * (-this.length);
    let ty = this.y + sin(ang) * (-this.length);
    return {x:tx,y:ty};
  }

  // compute path for debris to follow when caught: along rake arm up into collector
  computeCatchPath(point){
    // build points from current position to tip, then up along angled collector to a small bin
    let tip = this.tipPosition();
    let path = [];
    // first segment: current to tip
    path.push({x:point.x, y:point.y});
    path.push({x:tip.x, y:tip.y});
    // then along extended line from tip upwards into collector top
    let collectorTop = {
      x: this.x + cos(this.angle) * (-this.length - 26),
      y: this.y + sin(this.angle) * (-this.length - 26)
    };
    // final collection point (a bit further)
    let final = {
      x: collectorTop.x + cos(this.angle-10) * -30,
      y: collectorTop.y + sin(this.angle-10) * -36
    };
    path.push(collectorTop);
    path.push(final);
    // smooth out by adding interpolated midpoints
    let smooth = [];
    for (let i=0;i<path.length-1;i++){
      smooth.push(path[i]);
      let a = path[i], b = path[i+1];
      smooth.push({x:lerp(a.x,b.x,0.35), y:lerp(a.y,b.y,0.35)});
      smooth.push({x:lerp(a.x,b.x,0.65), y:lerp(a.y,b.y,0.65)});
    }
    smooth.push(path[path.length-1]);
    return smooth;
  }

  // click behavior invoked externally
  onClick(){
    this.clickCount++;
    if (this.clickCount === 1){
      // then_first: speed up
      this.rotationSpeedMultiplier = 2.6;
    } else {
      // then_next: toggle states each click
      if (this.rotationSpeedMultiplier > 1) this.rotationSpeedMultiplier = 0.6; else this.rotationSpeedMultiplier = 1.6;
    }
  }

  rotationSpeedNormalized(){
    return constrain(this.rotationSpeedMultiplier, 0.1, 3.5);
  }
}

/* Utility functions */

function mousePressed(){
  // map mouse to canvas coords
  let mx = mouseX, my = mouseY;
  // check rake click area (approx near flange)
  let rakeRadius = 30;
  if (dist(mx,my, rake.x, rake.y) < rakeRadius){
    rake.onClick();
    return;
  }
  // check each debris from topmost (drawn later) to earlier
  for (let i=debrisList.length-1;i>=0;i--){
    let d = debrisList[i];
    // approximate bounding box
    let dx = abs(mx - d.x);
    let dy = abs(my - d.y);
    if (dx < 30 * d.scale && dy < 22 * d.scale){
      d.onClick();
      return;
    }
  }
  // otherwise clicking background toggles global rotation
  // if clicked near top center we can toggle rake rotation
  // else no action
}

// small helper
function normalizeAngle(a){
  let aa = a % 360;
  if (aa > 180) aa -= 360;
  if (aa < -180) aa += 360;
  return aa;
}

// small numeric format helper
function nf(v,d,f){ return Number(v).toFixed(f); }

</script>
</body>
</html>