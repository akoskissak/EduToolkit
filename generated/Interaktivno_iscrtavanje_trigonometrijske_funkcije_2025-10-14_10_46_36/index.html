<!doctype html>
<html lang="sr">
<head>
  <meta charset="utf-8">
  <title>Interaktivno iscrtavanje trigonometrijske funkcije</title>
  <style>
    /* audience: srednjoškolci */
    :root{
      --bg:#f7fbff;
      --panel:#ffffff;
      --accent:#1f77b4;
      --muted:#666;
      --grid:#e1edf7;
      --axis:#2b2b2b;
      --toast-bg:#fffbe6;
      --toast-border:#ffd766;
    }
    html,body{height:100%;margin:0;font-family:Segoe UI, Roboto, Arial, sans-serif;background:var(--bg);color:#1a1a1a}
    .container{max-width:980px;margin:24px auto;padding:20px;background:linear-gradient(180deg,#ffffff 0%, #fbfdff 100%);box-shadow:0 6px 20px rgba(18,38,63,0.08);border-radius:10px}
    h1{margin:0 0 12px 0;font-size:22px;color:var(--axis)}
    p.description{margin:0 0 18px 0;color:var(--muted)}
    .canvas-wrap{display:flex;flex-direction:column;align-items:center;gap:12px}
    canvas{background:transparent;border-radius:6px;box-shadow:0 2px 8px rgba(20,40,80,0.04);max-width:100%;width:100%;height:420px}
    .controls{width:100%;display:flex;flex-direction:column;gap:12px;padding:12px;border-radius:8px;background:linear-gradient(180deg, rgba(31,119,180,0.03), rgba(31,119,180,0.01));box-sizing:border-box}
    .control-row{display:flex;align-items:center;gap:12px}
    .label{width:120px;font-weight:600;color:var(--accent)}
    .slider{flex:1;display:flex;gap:8px;align-items:center}
    input[type=range]{-webkit-appearance:none;height:10px;background:linear-gradient(90deg,#e6f2fb,#fff);border-radius:6px;outline:none;width:100%}
    input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;background:var(--accent);border-radius:50%;box-shadow:0 2px 6px rgba(31,119,180,0.35);cursor:pointer;border:3px solid #fff}
    .value{width:90px;text-align:right;color:var(--muted);font-weight:600}
    .formula{margin-top:6px;font-family:monospace;background:linear-gradient(90deg,#fff,#fbfdfe);padding:8px;border-radius:6px;border:1px solid #eef6fb;color:#0b3b5a}
    .legend{display:flex;gap:12px;align-items:center;margin-top:6px;color:var(--muted);font-size:13px}
    .legend .swatch{width:14px;height:14px;border-radius:3px;display:inline-block}
    .toast{position:relative}
    .toast .msg{position:absolute;right:0;top:-46px;background:var(--toast-bg);border:1px solid var(--toast-border);padding:8px 12px;border-radius:6px;box-shadow:0 6px 18px rgba(24,36,60,0.06);color:#6a4b00;font-weight:600;opacity:0;transform:translateY(6px);transition:all .28s ease}
    .msg.show{opacity:1;transform:translateY(0)}
    .footer-note{margin-top:10px;font-size:13px;color:var(--muted)}
    @media (max-width:640px){
      .label{width:100px;font-size:14px}
      .value{width:70px}
      canvas{height:360px}
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Interaktivno iscrtavanje trigonometrijske funkcije</h1>
    <p class="description">Ovaj interaktivni alat omogućava učenicima da vizuelno istraže trigonometrijske funkcije. Korisnik može menjati parametre funkcije (amplitudu, frekvenciju i fazni pomeraj), a graf se automatski osvežava. Na taj način učenici bolje razumeju kako promene parametara utiču na oblik funkcije.</p>

    <div class="canvas-wrap">
      <canvas id="graph" width="920" height="420"></canvas>
      <div class="controls" aria-label="Kontrole za parametre">
        <div class="control-row">
          <div class="label">Amplituda (A)</div>
          <div class="slider toast">
            <input id="amp" type="range" min="0" max="3" step="0.01" value="1">
            <div class="value" id="ampVal">1.00</div>
            <div class="msg" id="ampMsg"></div>
          </div>
        </div>

        <div class="control-row">
          <div class="label">Frekvencija (B)</div>
          <div class="slider toast">
            <input id="freq" type="range" min="0.1" max="5" step="0.01" value="1">
            <div class="value" id="freqVal">1.00</div>
            <div class="msg" id="freqMsg"></div>
          </div>
        </div>

        <div class="control-row">
          <div class="label">Fazni pomeraj (C)</div>
          <div class="slider toast">
            <input id="phase" type="range" min="-3.1416" max="3.1416" step="0.01" value="0">
            <div class="value" id="phaseVal">0.00</div>
            <div class="msg" id="phaseMsg"></div>
          </div>
        </div>

        <div class="formula" id="formula">y = 1 · sin(1 · x + 0)</div>
        <div class="legend"><span class="swatch" style="background:var(--accent)"></span><div>Plava linija: y = A · sin(Bx + C)</div></div>
        <div class="footer-note">Početno stanje: y = sin(x) (A=1, B=1, C=0). Klizači ispod grafa menjaju parametre. Klik na svaki klizač prvi put prikazuje objašnjenje prve reakcije, a narednim klikovima kraću informaciju o učinku.</div>
      </div>
    </div>
  </div>

<script>
/*
  audience: srednjoškolci
  Implementacija interakcija prema opisu:
  - Klizači ispod grafa: Amplituda, Frekvencija, Fazni pomeraj
  - Prvi put pomeranja: pokaže then_first poruku
  - Sledeći pokreti: pokažu then_next poruku
  - Animacije su glatke prilikom prelaska iz jedne konfiguracije u drugu
*/

/* --- Setup canvas and drawing --- */
const canvas = document.getElementById('graph');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
  // keep width responsive to container while maintaining drawing buffer size
  const rect = canvas.getBoundingClientRect();
  const DPR = window.devicePixelRatio || 1;
  const width = Math.min(document.querySelector('.container').clientWidth - 40, 920);
  canvas.style.width = width + 'px';
  const cssHeight = 420;
  canvas.style.height = cssHeight + 'px';
  canvas.width = Math.round(width * DPR);
  canvas.height = Math.round(cssHeight * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
  draw();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* Domain and ranges */
let xMin = -2 * Math.PI;
let xMax = 2 * Math.PI;
let yMin = -3;
let yMax = 3;

/* Current parameters and animation targets */
let params = {A:1, B:1, C:0};
let animTarget = {A:1, B:1, C:0};
let animStart = null;
let animDuration = 600; // ms
let startParams = {...params};

/* Click counts per control to implement then_first / then_next messages */
const clickCounts = {amp:0, freq:0, phase:0};

/* DOM elements */
const amp = document.getElementById('amp');
const freq = document.getElementById('freq');
const phase = document.getElementById('phase');
const ampVal = document.getElementById('ampVal');
const freqVal = document.getElementById('freqVal');
const phaseVal = document.getElementById('phaseVal');
const formula = document.getElementById('formula');

const ampMsg = document.getElementById('ampMsg');
const freqMsg = document.getElementById('freqMsg');
const phaseMsg = document.getElementById('phaseMsg');

/* Messages per JSON input (in Serbian) */
const messages = {
  amp_first: "graf se ponovo iscrta sa novom amplitudom (y = A * sin(x))",
  amp_next: "funkcija postaje viša ili niža u zavisnosti od vrednosti",
  freq_first: "graf se ponovo iscrta sa novom frekvencijom (y = sin(B * x))",
  freq_next: "talasi se zgušnjavaju ili razređuju na x-osi",
  phase_first: "graf se pomera ulevo ili udesno (y = sin(x + C))",
  phase_next: "funkcija se horizontalno translira"
};

/* Helper: show temporary message above a control */
function showMsg(el, text) {
  el.textContent = text;
  el.classList.add('show');
  // Clear existing timer if any
  clearTimeout(el._hideTimer);
  el._hideTimer = setTimeout(()=>{ el.classList.remove('show'); }, 2200);
}

/* Attach event handlers for click counting and input */
function handleFirstOrNext(id, firstText, nextText, elMsg) {
  clickCounts[id] = (clickCounts[id] || 0) + 1;
  if (clickCounts[id] === 1) {
    showMsg(elMsg, firstText);
  } else {
    showMsg(elMsg, nextText);
  }
}

/* When slider is moved, set animation target and start */
function startAnimationTo(targetA, targetB, targetC) {
  startParams = {...params};
  animTarget = {A:targetA, B:targetB, C:targetC};
  animStart = performance.now();
  requestAnimationFrame(animateStep);
}

/* Interpolation easing (easeOutCubic) */
function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

function animateStep(ts) {
  if (!animStart) { draw(); return; }
  const t = Math.min(1, (ts - animStart) / animDuration);
  const e = easeOutCubic(t);
  params.A = startParams.A + (animTarget.A - startParams.A) * e;
  params.B = startParams.B + (animTarget.B - startParams.B) * e;
  params.C = startParams.C + (animTarget.C - startParams.C) * e;
  draw();
  if (t < 1) {
    requestAnimationFrame(animateStep);
  } else {
    // finalize
    params = {...animTarget};
    animStart = null;
  }
}

/* Drawing utilities */
function mapX(x, w) {
  return (x - xMin) / (xMax - xMin) * w;
}
function mapY(y, h) {
  return h - (y - yMin) / (yMax - yMin) * h;
}

function drawGrid(w, h) {
  ctx.clearRect(0,0,w,h);

  // background subtle
  ctx.fillStyle = 'rgba(255,255,255,0.98)';
  ctx.fillRect(0,0,w,h);

  // vertical grid at multiples of PI/2
  ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');
  ctx.lineWidth = 1;
  ctx.beginPath();
  for (let k = Math.ceil(xMin/(Math.PI/2)); k <= Math.floor(xMax/(Math.PI/2)); k++) {
    const x = k * Math.PI/2;
    const sx = mapX(x,w);
    ctx.moveTo(sx, 0);
    ctx.lineTo(sx, h);
  }
  // horizontal grid lines at integer y
  for (let y = Math.ceil(yMin); y <= Math.floor(yMax); y++) {
    const sy = mapY(y,h);
    ctx.moveTo(0, sy);
    ctx.lineTo(w, sy);
  }
  ctx.stroke();

  // axes
  ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--axis');
  ctx.lineWidth = 1.3;
  ctx.beginPath();
  // x axis at y=0
  const y0 = mapY(0,h);
  ctx.moveTo(0, y0);
  ctx.lineTo(w, y0);
  // y axis at x=0
  const x0 = mapX(0,w);
  ctx.moveTo(x0, 0);
  ctx.lineTo(x0, h);
  ctx.stroke();

  // ticks and labels for x (π multiples)
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--muted');
  ctx.font = '12px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  for (let k = Math.ceil(xMin/Math.PI); k <= Math.floor(xMax/Math.PI); k++) {
    const x = k * Math.PI;
    const sx = mapX(x, w);
    ctx.fillText(labelPi(k), sx, y0 + 6);
  }
  // y labels
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  for (let y = Math.ceil(yMin); y <= Math.floor(yMax); y++) {
    const sy = mapY(y,h);
    ctx.fillText(y.toString(), x0 - 8, sy);
  }
}

function labelPi(k) {
  if (k === 0) return '0';
  if (k === 1) return 'π';
  if (k === -1) return '-π';
  return k + 'π';
}

/* Draw function curve */
function drawFunction(w,h) {
  ctx.lineWidth = 2.6;
  ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent');
  ctx.beginPath();
  const steps = Math.max(200, Math.round(w * 1.2));
  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    const x = xMin + (xMax - xMin) * t;
    const y = params.A * Math.sin(params.B * x + params.C);
    const sx = mapX(x,w);
    const sy = mapY(y,h);
    if (i === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
  }
  ctx.stroke();

  // small highlight at center x=0
  const yAt0 = params.A * Math.sin(params.B * 0 + params.C);
  ctx.fillStyle = 'rgba(31,119,180,0.12)';
  ctx.beginPath();
  ctx.arc(mapX(0,w), mapY(yAt0,h), 6, 0, Math.PI*2);
  ctx.fill();
}

/* Main draw */
function draw() {
  const w = canvas.width / (window.devicePixelRatio || 1);
  const h = canvas.height / (window.devicePixelRatio || 1);
  drawGrid(w,h);
  drawFunction(w,h);

  // draw formula badge on canvas top-right
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.strokeStyle = 'rgba(11,59,90,0.06)';
  ctx.lineWidth = 1;
  const pad = 10;
  const txt = `y = ${params.A.toFixed(2)} · sin(${params.B.toFixed(2)} · x + ${params.C.toFixed(2)})`;
  ctx.font = '13px monospace';
  const tw = ctx.measureText(txt).width + 12;
  const th = 26;
  const rx = w - tw - pad;
  const ry = pad;
  roundRect(ctx, rx, ry, tw, th, 6);
  ctx.fillStyle = '#05263a';
  ctx.fillText(txt, rx + tw/2, ry + th/2 + 4);
}

/* Helper to draw rounded rect fill */
function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
  ctx.fillStyle = 'rgba(255,255,255,0.95)';
  ctx.fill();
  ctx.strokeStyle = 'rgba(11,59,90,0.06)';
  ctx.stroke();
}

/* Initial draw */
draw();

/* --- Event wiring for sliders --- */
function updateDisplayedValues() {
  ampVal.textContent = parseFloat(amp.value).toFixed(2);
  freqVal.textContent = parseFloat(freq.value).toFixed(2);
  phaseVal.textContent = parseFloat(phase.value).toFixed(2);
  formula.textContent = `y = ${parseFloat(amp.value).toFixed(2)} · sin(${parseFloat(freq.value).toFixed(2)} · x + ${parseFloat(phase.value).toFixed(2)})`;
}

/* Add pointerdown (click) to count first vs next */
amp.addEventListener('pointerdown', ()=> {
  handleFirstOrNext('amp', messages.amp_first, messages.amp_next, ampMsg);
});
freq.addEventListener('pointerdown', ()=> {
  handleFirstOrNext('freq', messages.freq_first, messages.freq_next, freqMsg);
});
phase.addEventListener('pointerdown', ()=> {
  handleFirstOrNext('phase', messages.phase_first, messages.phase_next, phaseMsg);
});

/* input events start animation to new target */
amp.addEventListener('input', ()=> {
  updateDisplayedValues();
  const targetA = parseFloat(amp.value);
  startAnimationTo(targetA, animTarget.B, animTarget.C);
});
freq.addEventListener('input', ()=> {
  updateDisplayedValues();
  const targetB = parseFloat(freq.value);
  startAnimationTo(animTarget.A, targetB, animTarget.C);
});
phase.addEventListener('input', ()=> {
  updateDisplayedValues();
  const targetC = parseFloat(phase.value);
  startAnimationTo(animTarget.A, animTarget.B, targetC);
});

/* Also react to change end to ensure final values are set */
amp.addEventListener('change', ()=> {
  animTarget.A = parseFloat(amp.value);
});
freq.addEventListener('change', ()=> {
  animTarget.B = parseFloat(freq.value);
});
phase.addEventListener('change', ()=> {
  animTarget.C = parseFloat(phase.value);
});

/* Initialize displayed values */
updateDisplayedValues();

/* Smooth auto-animate when switching multiple sliders quickly:
   Keep animTarget up-to-date and if animation already running,
   animate from current on-screen params to new target */
function startAnimationTo(targetA, targetB, targetC) {
  // assign new target
  const newTarget = {A:targetA, B:targetB, C:targetC};
  // start from current on-canvas values (params), but if animation in progress, current params are accurate mid-animation
  startParams = {...params};
  animTarget = newTarget;
  animStart = performance.now();
  requestAnimationFrame(animateStep);
}

/* Make initial message visible on first interaction hints (not required by spec but helpful) */
function pulseInitialHint() {
  // show small brief hints for initial state above each slider with the 'first' messages (not intrusive)
  // We won't increment click counts here.
  // Leave commented out to avoid extra noise.
  // showMsg(ampMsg, messages.amp_first);
}
/* optional */
pulseInitialHint();

</script>
</body>
</html>