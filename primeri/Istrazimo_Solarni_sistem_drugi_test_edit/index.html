<html lang="hr"><head>
<meta charset="utf-8">
<title>Istrazimo Solarni sistem</title>
<style>
  /* Audience: osnovna i srednja škola, astronomija */
  /* Page layout */
  html,body{height:100%;margin:0;font-family:Segoe UI, Roboto, Arial;background:linear-gradient(#00111a,#001a26);color:#eef9ff}
  .container{max-width:1200px;margin:16px auto;padding:16px}
  h1{margin:0 0 8px 0;font-size:28px;color:#fff;text-align:center}
  p.description{margin:0 0 12px 0;color:#d7f1ff;text-align:center}
  .toolbar{display:flex;justify-content:center;gap:10px;margin-bottom:10px;flex-wrap:wrap}
  button, .toggle{background:#0b486b;color:#fff;border:none;padding:8px 12px;border-radius:6px;cursor:pointer;box-shadow:0 3px 0 rgba(0,0,0,0.3)}
  button:hover{transform:translateY(-1px)}
  .small{padding:6px 10px;font-size:13px}
  .controls{display:flex;gap:10px;align-items:center;justify-content:center;margin-bottom:6px}
  label{color:#bfe9ff;font-size:13px}
  #canvasWrapper{position:relative;border-radius:10px;overflow:hidden;background:radial-gradient(circle at 35% 15%, rgba(255,255,255,0.03), transparent 10%), #02131a; box-shadow:0 8px 30px rgba(0,0,0,0.6);padding:8px}
  canvas{display:block;background:transparent;max-width:100%;height:auto;border-radius:6px}
  .infoPanel{position:absolute;background:rgba(10,20,30,0.95);color:#e6f7ff;padding:10px;border-radius:8px;box-shadow:0 6px 20px rgba(0,0,0,0.7);max-width:260px;font-size:13px;border:1px solid rgba(180,240,255,0.06)}
  .infoPanel h3{margin:0 0 6px 0;font-size:15px;color:#ffd98c}
  .infoPanel p{margin:0 0 8px 0;color:#dff6ff}
  .infoPanel .panelButtons{display:flex;gap:6px;flex-wrap:wrap}
  .panelBtn{background:#09556b;padding:6px 8px;border-radius:6px;font-size:12px;cursor:pointer}
  .panelBtn:hover{opacity:0.95}
  .speedTag{background:rgba(255,255,255,0.06);padding:2px 6px;border-radius:4px;font-size:12px;color:#cfefff;margin-left:6px}
  .legend{display:flex;gap:12px;justify-content:center;margin-top:8px;color:#cfefff;font-size:13px}
  .legend div{display:flex;gap:6px;align-items:center}
  .dot{width:12px;height:12px;border-radius:50%}
  footer{margin-top:10px;text-align:center;color:#9bd9ff;font-size:12px}
  @media(max-width:700px){
    h1{font-size:20px}
    .container{padding:8px}
    .infoPanel{max-width:220px;font-size:12px}
  }
</style>
</head>
<body>
<div class="container">
  <h1>Istrazimo Solarni sistem</h1>
  <p class="description">Interaktivni alat koji omogućava učenicima da klikom na planete saznaju osnovne informacije o njima, kao i prikaz orbitnih putanja i animacija.</p>

  <div class="toolbar">
    <div class="controls">
      <button id="resetBtn" class="small">Resetuj pogled</button>
      <button id="toggleOrbits" class="small">Sakrij orbite</button>
      <button id="toggleSpeeds" class="small">Prikaži brzine</button>
      <button id="centerSun" class="small">Centriraj na Sunce</button>
    </div>
  </div>

  <div id="canvasWrapper">
    <canvas id="space" width="829" height="482"></canvas>
    <!-- Info panels will be injected here -->
  </div>

  <div class="legend" aria-hidden="true">
    <div><div class="dot" style="background: #ffd27f"></div> Sunce</div>
    <div><div class="dot" style="background: #ffd98c"></div> Merkur</div>
    <div><div class="dot" style="background: #e6cda3"></div> Venera</div>
    <div><div class="dot" style="background: #6fb7ff"></div> Zemlja</div>
    <div><div class="dot" style="background: #ff8c6b"></div> Mars</div>
    <div><div class="dot" style="background: #ffb873"></div> Jupiter</div>
  </div>

  <footer>Kliknite na Merkura ili Jupiter za informacije. Možete zumirati i prikazati brzine orbita.</footer>
</div>

<script>
/*
  Audience metadata (comment): osnovna i srednja škola, astronomija
  This interactive demo shows the solar system. Click planets to get info and trigger animations.
*/

(function(){
  const canvas = document.getElementById('space');
  const wrapper = document.getElementById('canvasWrapper');
  const ctx = canvas.getContext('2d');

  // Responsive canvas sizing within wrapper
  function resizeCanvas(){
    const maxW = Math.min(window.innerWidth - 40, 1100);
    canvas.width = maxW;
    // keep aspect ratio approx 16:9
    canvas.height = Math.round(maxW * 640 / 1100);
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // Camera and transforms
  let camera = {
    scale: 1,
    tx: 0, // translation in world coords
    ty: 0,
    targetScale: 1,
    targetTx: 0,
    targetTy: 0
  };

  function applyCameraTransform(){
    ctx.setTransform(1,0,0,1,0,0);
    // center of canvas as origin for world coords (sun position)
    const cx = canvas.width/2, cy = canvas.height/2;
    ctx.translate(cx, cy);
    ctx.scale(camera.scale, camera.scale);
    ctx.translate(camera.tx, camera.ty);
  }

  // Solar system data (distances and sizes are visual not to scale)
  const sun = {
    name: 'Sunce',
    radius: 36,
    color: '#ffd27f',
  };

  // Planets: name, color, radius, orbitRadius (distance from sun center), orbitalPeriod (seconds per full orbit)
  const planets = [
    {name:'Merkur', color:'#ffd98c', radius:6, orbit:70, period:8, angle: Math.random()*Math.PI*2, clickCount:0, panelPos:'below', id:'merkur'},
    {name:'Venera', color:'#e6cda3', radius:9, orbit:110, period:22, angle: Math.random()*Math.PI*2, clickCount:0, id:'venera'},
    {name:'Zemlja', color:'#6fb7ff', radius:10, orbit:150, period:30, angle: Math.random()*Math.PI*2, clickCount:0, id:'zemlja'},
    {name:'Mars', color:'#ff8c6b', radius:8, orbit:190, period:56, angle: Math.random()*Math.PI*2, clickCount:0, id:'mars'},
    {name:'Jupiter', color:'#ffb873', radius:20, orbit:260, period:120, angle: Math.random()*Math.PI*2, clickCount:0, panelPos:'right', id:'jupiter'},
    {name:'Saturn', color:'#f2e0b6', radius:16, orbit:330, period:330, angle: Math.random()*Math.PI*2, clickCount:0, id:'saturn'},
    {name:'Uran', color:'#cce8ff', radius:13, orbit:390, period:800, angle: Math.random()*Math.PI*2, clickCount:0, id:'uran'},
    {name:'Neptun', color:'#8fbaff', radius:13, orbit:450, period:1400, angle: Math.random()*Math.PI*2, clickCount:0, id:'neptun'}
  ];

  // Settings
  let showOrbits = true;
  let showSpeeds = false;

  // Additional per-planet states (animations triggered by interactions)
  const planetStates = {
    merkur: { rotationOn: false, rotationAngle: 0 },
    jupiter: { ringsOn: false, ringsAngle: 0 }
  };

  // Info panel management
  const panels = {}; // keyed by planet id

  // Interaction rules parsed from input JSON (hard-coded per user's content)
  const rules = {
    merkur: {
      if: 'klik na Merkur',
      then_first: "Merkur – najmanja planeta, najbliža Suncu, nema atmosferu.",
      then_next: [
        "Dodaj animaciju rotacije Merkura i promeni tekst na: 'Merkur se okreće sporo, dan traje 58 Zemljinih dana.'"
      ],
      position: 'Planeta Merkur, mala žuta sfera najbliža Suncu.',
      style: 'Sfera sa blago sjajnom teksturom, panel sa opisom se pojavljuje ispod planeta.'
    },
    jupiter: {
      if: 'klik na Jupiter',
      then_first: "Jupiter – najveća planeta, gasoviti div sa velikim crvenim pegama.",
      then_next: [
        "Dodaj animaciju njegovih prstenova i promeni tekst na: 'Jupiterova gravitacija utiče na ostale planete.'"
      ],
      position: 'Velika narandžasta sfera sa crvenim pegama, desno od centra.',
      style: 'Sfera sa animiranim prstenovima, panel se pojavljuje pored planete.'
    }
  };

  // Comet system: animate comets that pass near Mars
  const comets = []; // active comets

  function spawnCometNearMars(){
    const mars = planets.find(p=>p.id==='mars');
    if(!mars || typeof mars._x === 'undefined') return;
    // Start position: far outside current visible orbits in direction opposite to Mars
    const spawnRadius = Math.max(520, Math.max(...planets.map(p=>p.orbit))) + 160;
    // direction from sun to Mars
    const mx = mars._x, my = mars._y;
    const magM = Math.sqrt(mx*mx + my*my) || 1;
    // spawn roughly opposite side of Mars so it will pass by Mars when moving towards the center
    const sx = - (mx / magM) * spawnRadius + (Math.random()-0.5)*80;
    const sy = - (my / magM) * spawnRadius + (Math.random()-0.5)*80;
    // target point near Mars (offset so it "passes by")
    const offset = 40 + Math.random()*30;
    const tx = mx + (Math.random()>0.5 ? offset : -offset);
    const ty = my + (Math.random()>0.5 ? offset : -offset);
    // velocity towards target
    const vx0 = tx - sx, vy0 = ty - sy;
    const vmag = Math.sqrt(vx0*vx0 + vy0*vy0) || 1;
    const speed = 260 + Math.random()*120; // world units per second
    const vx = (vx0/vmag) * speed;
    const vy = (vy0/vmag) * speed;
    const comet = {
      x: sx,
      y: sy,
      vx, vy,
      trail: [],
      maxTrail: 28,
      age: 0,
      life: 12 + Math.random()*6,
      size: 5 + Math.random()*4,
      glowColor: 'rgba(255,250,220,0.95)',
      tailColor: 'rgba(180,220,255,0.85)'
    };
    comets.push(comet);
  }

  // spawn periodically
  let cometSpawner = setInterval(spawnCometNearMars, 10000 + Math.random()*6000);

  // Utility: world to screen transform considering camera
  function worldToScreen(x, y){
    const cx = canvas.width/2, cy = canvas.height/2;
    const sx = cx + ( (x + camera.tx) * camera.scale );
    const sy = cy + ( (y + camera.ty) * camera.scale );
    return {x:sx, y:sy};
  }
  function screenToWorld(sx, sy){
    const cx = canvas.width/2, cy = canvas.height/2;
    const x = (sx - cx)/camera.scale - camera.tx;
    const y = (sy - cy)/camera.scale - camera.ty;
    return {x,y};
  }

  // Draw loop
  let lastTime = 0;
  function animate(time){
    if(!lastTime) lastTime = time;
    const dt = (time - lastTime)/1000; // in seconds
    lastTime = time;

    // update planetary angles based on orbital period
    planets.forEach(p => {
      const angularSpeed = (2*Math.PI) / p.period; // radians per second
      p.angle += angularSpeed * dt;
    });

    // update special animations
    if(planetStates.merkur.rotationOn){
      planetStates.merkur.rotationAngle += dt * (Math.PI/4); // rotation on its axis
    }
    if(planetStates.jupiter.ringsOn){
      planetStates.jupiter.ringsAngle += dt * 0.6;
    }

    // update comets
    updateComets(dt);

    // animate camera smoothing
    const smoothing = 0.12;
    camera.scale += (camera.targetScale - camera.scale) * smoothing;
    camera.tx += (camera.targetTx - camera.tx) * smoothing;
    camera.ty += (camera.targetTy - camera.ty) * smoothing;

    // draw
    ctx.clearRect(0,0,canvas.width,canvas.height);
    applyCameraTransform();

    // draw star field (a subtle static background within world coords)
    drawStars();

    // draw orbits
    if(showOrbits){
      planets.forEach(p => drawOrbit(p.orbit));
    }

    // draw sun glow
    drawSun();

    // draw planets
    planets.forEach(p => drawPlanet(p));

    // draw comets on top of planets so tail and head are visible
    comets.forEach(c => drawComet(c));

    // restore default transform for UI overlays if needed
    ctx.setTransform(1,0,0,1,0,0);

    requestAnimationFrame(animate);
  }

  // Draw helpers
  function drawStars(){
    // faint background sprinkled stars with parallax effect based on camera
    // We'll draw a few static star points (for simplicity)
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.05)';
    const starCoords = [
      [-520,-180],[-300,-140],[-120,-240],[80,-260],[260,-180],[460,-120],
      [-420,100],[-160,200],[-20,120],[140,220],[360,40],[520,160]
    ];
    starCoords.forEach(s=>{
      ctx.beginPath();
      ctx.arc(s[0], s[1], 1.2, 0, Math.PI*2);
      ctx.fill();
    });
    ctx.restore();
  }

  function drawOrbit(r){
    ctx.save();
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(180,230,255,0.08)';
    ctx.lineWidth = 1 / Math.max(camera.scale, 0.2);
    ctx.setLineDash([4,6]);
    ctx.ellipse(0,0,r, r*0.98, 0, 0, Math.PI*2);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }

  function drawSun(){
    ctx.save();
    // glow
    const grd = ctx.createRadialGradient(0,0,sun.radius*0.2, 0,0, sun.radius*3.5);
    grd.addColorStop(0, 'rgba(255,230,160,0.95)');
    grd.addColorStop(0.3,'rgba(255,210,110,0.55)');
    grd.addColorStop(1, 'rgba(255,210,110,0.06)');
    ctx.fillStyle = grd;
    ctx.beginPath(); ctx.arc(0,0,sun.radius*3.5,0,Math.PI*2); ctx.fill();

    // body
    ctx.beginPath();
    ctx.fillStyle = sun.color;
    ctx.shadowColor = 'rgba(255,190,100,0.45)';
    ctx.shadowBlur = 24;
    ctx.arc(0,0,sun.radius,0,Math.PI*2);
    ctx.fill();

    // subtle surface swirls
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 0.06;
    ctx.fillStyle = '#ffffff';
    for(let i=0;i<6;i++){
      ctx.beginPath();
      ctx.ellipse(Math.cos(i)*6, Math.sin(i)*6, sun.radius*0.9 - i*3, sun.radius*0.4 - i, 0.4*i, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function drawPlanet(p){
    ctx.save();
    // compute position
    const x = Math.cos(p.angle) * p.orbit;
    const y = Math.sin(p.angle) * p.orbit * 0.98;
    p._x = x; p._y = y; // store for click detection & UI positioning

    // shadow for depth
    ctx.beginPath();
    ctx.fillStyle='rgba(0,0,0,0.12)';
    ctx.ellipse(x+p.radius*0.9, y+p.radius*1.1, p.radius*1.1, p.radius*0.5, 0, 0, Math.PI*2);
    ctx.fill();

    // planet body
    const grad = ctx.createRadialGradient(x - p.radius*0.4, y - p.radius*0.4, p.radius*0.2, x, y, p.radius);
    grad.addColorStop(0, 'rgba(255,255,255,0.65)');
    grad.addColorStop(0.18, p.color);
    grad.addColorStop(1, shadeColor(p.color, -18));
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(x,y,p.radius,0,Math.PI*2);
    ctx.fill();

    // small identifying markings
    if(p.id === 'jupiter'){
      // draw red spot(s)
      ctx.fillStyle = '#b24a3a';
      ctx.beginPath();
      ctx.ellipse(x + p.radius*0.35, y - p.radius*0.2, p.radius*0.6, p.radius*0.38, -0.3 + Math.sin(p.angle*0.5)*0.05, 0, Math.PI*2);
      ctx.fill();
    } else if(p.id === 'merkur'){
      // a small crater-like dot to show rotation if enabled
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      const craterAngle = planetStates.merkur.rotationAngle || 0;
      const cx = x + Math.cos(craterAngle)* (p.radius*0.45);
      const cy = y + Math.sin(craterAngle)* (p.radius*0.45);
      ctx.beginPath(); ctx.arc(cx, cy, Math.max(1, p.radius*0.25), 0, Math.PI*2); ctx.fill();
    }

    // Saturn rings example (draw static rings if planet is Saturn)
    if(p.id === 'saturn'){
      ctx.save();
      ctx.translate(x,y);
      ctx.rotate(0.45);
      ctx.strokeStyle = 'rgba(220,200,160,0.55)';
      ctx.lineWidth = p.radius*0.6;
      ctx.beginPath();
      ctx.ellipse(0,0,p.radius*2.3, p.radius*1.05, 0, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    // Jupiter rings (animated if turned on by interaction)
    if(p.id === 'jupiter'){
      ctx.save();
      ctx.translate(x,y);
      const base = p.radius*1.8;
      if(planetStates.jupiter.ringsOn){
        ctx.rotate(planetStates.jupiter.ringsAngle);
      } else {
        ctx.rotate(0.14);
      }
      ctx.strokeStyle = 'rgba(200,150,120,0.28)';
      ctx.lineWidth = Math.max(1, p.radius*0.8);
      ctx.beginPath();
      ctx.ellipse(0,0, base*1.25, base*0.62, 0, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    // optional label (small)
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.font = `${Math.max(9, Math.round(p.radius*0.7))}px Arial`;
    ctx.textAlign = 'center';
    ctx.fillText('', x, y + p.radius + 12);

    // show speed tag if enabled
    if(showSpeeds){
      ctx.save();
      ctx.font = '12px Arial';
      ctx.fillStyle = 'rgba(200,240,255,0.95)';
      const speed = ((2*Math.PI)/p.period).toFixed(3);
      ctx.fillText('v:' + speed, x + p.radius + 20, y);
      ctx.restore();
    }

    ctx.restore();
  }

  // Comet update & draw
  function updateComets(dt){
    for(let i=comets.length-1;i>=0;i--){
      const c = comets[i];
      c.age += dt;
      // move
      c.x += c.vx * dt;
      c.y += c.vy * dt;
      // add to trail
      c.trail.unshift({x:c.x, y:c.y});
      if(c.trail.length > c.maxTrail) c.trail.pop();
      // gradually slow a little for nicer curve
      c.vx *= 0.9995;
      c.vy *= 0.9995;
      // remove if too old or far away
      const distFromCenter = Math.sqrt(c.x*c.x + c.y*c.y);
      if(c.age > c.life || distFromCenter > 1600) {
        comets.splice(i,1);
      }
    }
  }

  function drawComet(c){
    ctx.save();
    // draw tail (fading)
    for(let i = 0; i < c.trail.length; i++){
      const t = c.trail[i];
      const alpha = (1 - i / c.trail.length) * 0.75;
      const size = (c.size * (1 - i / (c.trail.length*1.1))) + 0.5;
      ctx.beginPath();
      ctx.fillStyle = `rgba(180,220,255,${alpha * 0.8})`;
      ctx.arc(t.x, t.y, size, 0, Math.PI*2);
      ctx.fill();
    }
    // draw glowing head
    ctx.beginPath();
    const headGrd = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, c.size*6);
    headGrd.addColorStop(0, 'rgba(255,255,230,0.95)');
    headGrd.addColorStop(0.2, 'rgba(255,240,200,0.55)');
    headGrd.addColorStop(1, 'rgba(180,220,255,0.04)');
    ctx.fillStyle = headGrd;
    ctx.arc(c.x, c.y, c.size*6, 0, Math.PI*2);
    ctx.fill();

    ctx.beginPath();
    ctx.fillStyle = c.glowColor;
    ctx.arc(c.x, c.y, c.size, 0, Math.PI*2);
    ctx.fill();

    // small bright core
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.arc(c.x, c.y, Math.max(1, c.size*0.45), 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  // Utility to shade color
  function shadeColor(hex, percent) {
      // hex like #rrggbb
      const f = hex.slice(1);
      const t = percent<0?0:255;
      const p = Math.abs(percent)/100;
      const R = parseInt(f.substring(0,2),16);
      const G = parseInt(f.substring(2,4),16);
      const B = parseInt(f.substring(4,6),16);
      const newR = Math.round((t - R)*p) + R;
      const newG = Math.round((t - G)*p) + G;
      const newB = Math.round((t - B)*p) + B;
      return '#' + ( (1<<24) + (newR<<16) + (newG<<8) + newB ).toString(16).slice(1);
  }

  // Interaction: clicks on canvas
  canvas.addEventListener('click', function(evt){
    const rect = canvas.getBoundingClientRect();
    const sx = evt.clientX - rect.left;
    const sy = evt.clientY - rect.top;
    const world = screenToWorld(sx, sy);

    // find if click hits a planet (closest, with radius)
    let clicked = null;
    for(let i=0;i<planets.length;i++){
      const p = planets[i];
      const dx = world.x - p._x;
      const dy = world.y - p._y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if(dist <= p.radius + 4){ clicked = p; break; }
    }
    if(clicked){
      handlePlanetClick(clicked);
    }
  });

  // Handle logic per planet per rules with clickCount tracking
  function handlePlanetClick(p){
    p.clickCount = (p.clickCount||0) + 1;
    const id = p.id;
    const rule = rules[id];
    if(!rule) {
      // create a simple info panel for other planets
      showInfoPanel(p, `<strong>${p.name}</strong>`, `Osnovne informacije o ${p.name}. Orbit: ${p.orbit}px, veličina: ${p.radius}px.`);
      return;
    }

    const step = p.clickCount;
    if(step === 1){
      // then_first action
      const text = rule.then_first;
      showInfoPanelForRule(p, text, 0);
    } else {
      // subsequent actions: apply then_next sequentially based on (step-2)
      const idx = step - 2;
      if(idx < rule.then_next.length){
        const act = rule.then_next[idx];
        applyActionText(p, act);
      } else {
        // loop last action if more clicks
        const act = rule.then_next[rule.then_next.length-1];
        applyActionText(p, act);
      }
    }
  }

  // Show info panel with positioning based on planet data
  function showInfoPanelForRule(p, text, thenNextIndex){
    // Determine panel content and placement
    const id = p.id;
    const existing = panels[id];
    const title = p.name;
    let body = text;
    // create or update
    createOrUpdatePanel(p, title, body);
  }

  function createOrUpdatePanel(p, title, body){
    const id = p.id;
    let panel = panels[id];
    if(!panel){
      panel = document.createElement('div');
      panel.className = 'infoPanel';
      panel.dataset.planet = id;
      panel.innerHTML = `<h3>${title}</h3><p class="desc">${body}</p><div class="panelButtons"></div>`;
      wrapper.appendChild(panel);
      panels[id] = panel;
      // add panel buttons
      const btnContainer = panel.querySelector('.panelButtons');
      const zoomBtn = document.createElement('div');
      zoomBtn.className = 'panelBtn';
      zoomBtn.textContent = 'Zumiraj';
      zoomBtn.onclick = ()=> zoomToPlanet(p, 1.6);
      btnContainer.appendChild(zoomBtn);

      const orbitBtn = document.createElement('div');
      orbitBtn.className = 'panelBtn';
      orbitBtn.textContent = showOrbits ? 'Sakrij orbitu' : 'Prikaži orbitu';
      orbitBtn.onclick = ()=>{
        showOrbits = !showOrbits;
        orbitBtn.textContent = showOrbits ? 'Sakrij orbitu' : 'Prikaži orbitu';
        document.getElementById('toggleOrbits').textContent = showOrbits ? 'Sakrij orbite' : 'Prikaži orbite';
      };
      btnContainer.appendChild(orbitBtn);

      const closeBtn = document.createElement('div');
      closeBtn.className = 'panelBtn';
      closeBtn.textContent = 'Zatvori';
      closeBtn.onclick = ()=> {
        panel.remove();
        delete panels[id];
      };
      btnContainer.appendChild(closeBtn);

      // Additional: zoom controls small
      const zoomIn = document.createElement('div');
      zoomIn.className = 'panelBtn';
      zoomIn.textContent = '+';
      zoomIn.onclick = ()=> adjustCameraScale(camera.targetScale*1.2);
      btnContainer.appendChild(zoomIn);

      const zoomOut = document.createElement('div');
      zoomOut.className = 'panelBtn';
      zoomOut.textContent = '−';
      zoomOut.onclick = ()=> adjustCameraScale(camera.targetScale/1.2);
      btnContainer.appendChild(zoomOut);
    } else {
      panel.querySelector('h3').textContent = title;
      panel.querySelector('.desc').innerHTML = body;
    }

    // Position panel relative to planet screen position
    positionPanelNearPlanet(p, panel);
  }

  function positionPanelNearPlanet(p, panel){
    // compute planet screen pos
    const screen = worldToScreen(p._x, p._y);
    const rect = wrapper.getBoundingClientRect();
    // default positions based on p.panelPos
    const pad = 8;
    let left = screen.x + rect.left;
    let top = screen.y + rect.top;
    // adjust relative to wrapper coordinates
    // position: below or right as specified
    if(p.panelPos === 'below'){
      left = screen.x - panel.offsetWidth/2;
      top = screen.y + 12;
    } else if(p.panelPos === 'right'){
      left = screen.x + 12;
      top = screen.y - panel.offsetHeight/2;
    } else {
      left = screen.x + 12;
      top = screen.y + 12;
    }

    // clamp within wrapper
    const wrapRect = wrapper.getBoundingClientRect();
    const relLeft = left - wrapRect.left;
    const relTop = top - wrapRect.top;
    // ensure within wrapper
    const clampedLeft = Math.max(6, Math.min(relLeft, wrapRect.width - panel.offsetWidth - 6));
    const clampedTop = Math.max(6, Math.min(relTop, wrapRect.height - panel.offsetHeight - 6));
    panel.style.left = clampedLeft + 'px';
    panel.style.top = clampedTop + 'px';
  }

  function applyActionText(p, action){
    // parse action textual instructions
    const id = p.id;
    if(id === 'merkur'){
      if(action.includes('Dodaj animaciju rotacije Merkura')){
        planetStates.merkur.rotationOn = true;
        const panelText = "Merkur se okreće sporo, dan traje 58 Zemljinih dana.";
        createOrUpdatePanel(p, 'Merkur', panelText);
      } else {
        createOrUpdatePanel(p, p.name, action);
      }
    } else if(id === 'jupiter'){
      if(action.includes('Dodaj animaciju njegovih prstenova')){
        planetStates.jupiter.ringsOn = true;
        const panelText = "Jupiterova gravitacija utiče na ostale planete.";
        createOrUpdatePanel(p, 'Jupiter', panelText);
      } else {
        createOrUpdatePanel(p, p.name, action);
      }
    } else {
      createOrUpdatePanel(p, p.name, action);
    }
  }

  function showInfoPanel(p, title, text){
    createOrUpdatePanel(p, title, text);
  }

  // Zoom functionality
  function zoomToPlanet(p, scale=1.8){
    // convert planet world coords to camera target tx,ty such that planet centers on screen
    const targetScale = scale;
    const sx = p._x, sy = p._y;
    // camera tx/ty are world translations applied after centering at canvas center
    camera.targetScale = targetScale;
    camera.targetTx = -sx;
    camera.targetTy = -sy;
  }

  function adjustCameraScale(s){
    camera.targetScale = Math.max(0.4, Math.min(3.2, s));
  }

  // Reset view
  document.getElementById('resetBtn').addEventListener('click', function(){
    // reset camera
    camera.targetScale = 1;
    camera.targetTx = 0;
    camera.targetTy = 0;
    // reset planets to initial positions (random initial angles replaced by fixed)
    planets.forEach((p,i)=>{
      p.angle = (i+1)*0.5; // deterministic starting layout
      p.clickCount = 0;
    });
    // disable special animations
    planetStates.merkur.rotationOn = false;
    planetStates.merkur.rotationAngle = 0;
    planetStates.jupiter.ringsOn = false;
    planetStates.jupiter.ringsAngle = 0;
    // remove panels
    for(const k in panels){
      const el = panels[k];
      if(el) el.remove();
    }
    for(const k in panels) delete panels[k];
    // clear comets
    comets.length = 0;
  });

  // Toggle orbit visibility
  document.getElementById('toggleOrbits').addEventListener('click', function(){
    showOrbits = !showOrbits;
    this.textContent = showOrbits ? 'Sakrij orbite' : 'Prikaži orbite';
  });

  // Toggle speeds display
  document.getElementById('toggleSpeeds').addEventListener('click', function(){
    showSpeeds = !showSpeeds;
    this.textContent = showSpeeds ? 'Sakrij brzine' : 'Prikaži brzine';
  });

  // Center on Sun
  document.getElementById('centerSun').addEventListener('click', function(){
    camera.targetScale = 1;
    camera.targetTx = 0;
    camera.targetTy = 0;
  });

  // reposition panels on window resize or animation (they follow planets)
  function updatePanelsPosition(){
    for(const id in panels){
      const p = planets.find(pp=>pp.id===id);
      if(p){
        positionPanelNearPlanet(p, panels[id]);
      }
    }
  }
  // update panel positions periodically (per frame)
  setInterval(updatePanelsPosition, 80);

  // Initialize: small animation intro
  function init(){
    // set initial angles for nice layout
    planets.forEach((p,i)=>{
      p.angle = (i+1) * 0.6;
    });
    requestAnimationFrame(animate);
  }

  init();

  // Accessibility: keyboard shortcuts to zoom to Mercury/Jupiter for convenience
  window.addEventListener('keydown', (e)=>{
    if(e.key.toLowerCase() === 'm'){
      const p = planets.find(pp=>pp.id==='merkur');
      if(p) zoomToPlanet(p, 2.0);
    } else if(e.key.toLowerCase() === 'j'){
      const p = planets.find(pp=>pp.id==='jupiter');
      if(p) zoomToPlanet(p, 1.6);
    } else if(e.key === 'Escape'){
      // close all panels
      for(const k in panels){
        panels[k].remove();
        delete panels[k];
      }
    }
  });

  // Ensure panels remain readable when camera moves: reposition after camera settles
  setInterval(()=> {
    for(const id in panels){
      const panel = panels[id];
      const p = planets.find(pp=>pp.id===id);
      if(panel && p) positionPanelNearPlanet(p, panel);
    }
  }, 200);

})();
</script>

</body></html>